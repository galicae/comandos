[
  {
    "objectID": "dotplot_util.html",
    "href": "dotplot_util.html",
    "title": "dotplot_util",
    "section": "",
    "text": "This module contains a collection of utility functions for the pairwise dotplots, as well as some more general functions that are used in the dotplot generation process. I wrote documentation for the functions here, but I didn’t write tests for them. I’m not sure this page is very valuable to end users.\n\nsource\n\nhighlight_cluster\n\ndef highlight_cluster(\n    clusters:ndarray, # The array of cluster names.\n    cluster:Optional=None, # The cluster to highlight (default: None).\n    bg:Union='black', # The background color. Accepts all matplotlib-compatible color formats (default: \"black\").\n    hl:Union='red', # The highlight color. Accepts all matplotlib-compatible color formats (default: \"red\").\n)-&gt;ndarray: # The array of colors, with the same length as `clusters`.\n\nHighlight a cluster in a list of clusters by setting the color of the cluster to hl and the color of the rest to bg.\n\nsource\n\n\nunique_genes\n\ndef unique_genes(\n    connections:ndarray, # The array of connections. Columns should be (query_genes, target_genes, connection_strength). The last column is optional.\n)-&gt;ndarray: # The array of unique genes.\n\nExtract the unique gene names from an array of connections.\n\nsource\n\n\nmap_to_colormap\n\ndef map_to_colormap(\n    x:ndarray, # The array to map.\n    cmap:Union='magma_r', # The color map to use. Should be a matplotlib colormap object or a string with the name of a matplotlib colormap (default: \"magma_r\").\n    vmin:float=0, # The value to obtain the minimum color in the colormap. Should be &lt;= np.min(x) to avoid truncation (default: 0).\n    vmax:Optional=None, # The value to obtain the maximum color in the colormap. Should be &gt;= np.max(x), and will use np.max(x) if set to `None` (default: None).\n)-&gt;ndarray: # Array of RGBA values with a shape of ``x.shape + (4, )``.\n\nMap an array of values to a color palette.\n\nsource\n\n\nmap_array_to_color\n\ndef map_array_to_color(\n    x:ndarray, # The array to map.\n    palette:Colormap, # The color map to use. Should be a matplotlib colormap object.\n    xmax:Optional=None, # The maximum value to use for normalization. Should be &gt;= np.max(x), and will use np.max(x) if set to `None` (default: None).\n)-&gt;ndarray: # Array of RGBA values with a shape of ``x.shape + (4, )``.\n\nMap an array of values to a color palette.\n\nsource\n\n\nadd_homology_context\n\ndef add_homology_context(\n    connections:ndarray, # The connections between genes. The columns should be (query_gene, target_gene).\n    orthology:DataFrame, # The orthology information as a DataFrame.\n)-&gt;ndarray: # The connections array with homology context added. The columns will be (query_gene,\ntarget_gene, connection_strength), and the values in connection_strength will depend on the\ncontent of the orthology DataFrame.\n\nAdd homology context to the given connections based on the orthology information.\n\nsource\n\n\nplot_dotplot\n\ndef plot_dotplot(\n    query_avg_expr:ndarray, # Array representing the average expression values of query genes.\n    target_avg_expr:ndarray, # Array representing the average expression values of target genes.\n    query_perc_expr:ndarray, # Array representing the percentage expression values of query genes.\n    target_perc_expr:ndarray, # Array representing the percentage expression values of target genes.\n    query_genes:List, # List of query gene names.\n    target_genes:List, # List of target gene names.\n    connections:ndarray, # An array where each row contains two genes and (optionally) the strength of their\nconnection.\n    query_cluster_colors:Dict, # Dictionary mapping query cluster names to their colors.\n    target_cluster_colors:Dict, # Dictionary mapping target cluster names to their colors.\n    query_gene_colors:Dict, # Dictionary mapping query gene names to their colors.\n    target_gene_colors:Dict, # Dictionary mapping target gene names to their colors.\n    query_species:str, # Species name of the query genes.\n    target_species:str, # Species name of the target genes.\n    x_offset:float=1, # Offset for the x-axis (default: 1).\n    y_offset:float=0, # Offset for the y-axis (default: 0).\n    grid_offset:int=30, # Offset for the grid spacing (default: 30).\n    query_clustering:str='leiden', # Clustering method for the query genes (default: \"leiden\").\n    target_clustering:str='leiden', # Clustering method for the target genes (default: \"leiden\").\n    output:str='./paired_dotplot.png', # Output file path for the plot (default: \"./paired_dotplot.png\").\n    title:Optional=None, # Title of the plot (default: None).\n    title_font_size:int=16, # Font size of the plot title (default: 16).\n    center:bool=True, # Whether to center the dotplots when the number of genes exceeds the maximum (default: True).\n    cmap:Colormap='magma_r'\n)-&gt;None:\n\nPlot the paired dotplot based on the given data.\n\nsource\n\n\nadd_connections\n\ndef add_connections(\n    fig:Figure, # The paired dotplot figure to which the connections will be added.\n    connections:ndarray, # An array where each row contains two genes and (optionally) the strength of their\nconnection.\n    query_gene_names:List, # The list of query gene names.\n    query_gene_colors:Dict, # The dictionary mapping query gene names to their colors.\n    label_offset:float, # The offset for label positioning.\n)-&gt;None:\n\nAdd connections between genes to the given paired dotplot figure.\n\nsource\n\n\nmake_dotplot\n\ndef make_dotplot(\n    ax:Axes, # The Axes object on which to create the dotplot.\n    avg:ndarray, # The average expression values.\n    perc:ndarray, # The percentage expression values.\n    gene_names:List, # The list of gene names.\n    species:str, # The species name.\n    clustering:str, # The clustering information.\n    clust_color:List, # The list of colors for clusters.\n    gene_color:List, # The list of colors for genes.\n    side:str='left', # The side to place the y-axis labels, either \"left\" or \"right\" (default: \"left\").\n    cmap:Colormap='magma_r'\n)-&gt;None:\n\nMake a dotplot on the given Axes object based on the average and percentage expression values.\n\nsource\n\n\nplot_colorbar_legend\n\ndef plot_colorbar_legend(\n    cbar_legend:Axes, # The Axes object representing the colorbar legend.\n    query_avg_expr:ndarray, # Array representing the average expression values of query genes.\n    target_avg_expr:ndarray, # Array representing the average expression values of target genes.\n    cmap:Colormap='magma_r', # The Colormap instance or registered colormap name used to map scalar data to colors\n(default: \"magma_r\").\n)-&gt;None:\n\nPlot the colorbar legend based on the average expression values of query and target genes.\n\nsource\n\n\nplot_dot_legend\n\ndef plot_dot_legend(\n    dot_legend, # The subplot of the grid that contains the dotplot legend.\n    size_exponent:float=1.5, # The exponent to raise the fraction of cells in a group to, to get the dot size. The default\nis 1.5.\n    dot_size:int=200, # The size of the largest dot. The default is 200.\n):\n\nCreate the dotplot legend, explaining dot size.\n\nsource\n\n\nget_dot_color\n\ndef get_dot_color(\n    query:AnnData, # The query dataset.\n    target:AnnData, # The target dataset.\n    query_clustering:str, # The .obs column name to use for the query dataset.\n    target_clustering:str, # The .obs column name to use for the target dataset.\n    query_genes:Optional=None, # Array of query genes to subset the data, if any. If None, use all genes (default: None).\n    target_genes:Optional=None, # Array of target genes to subset the data, if any. If None, use all genes (default: None).\n    query_gene_names:Optional=None, # Array of query gene names (default: None).\n    target_gene_names:Optional=None, # Array of target gene names (default: None).\n    layer:Optional=None, # The layer to use for the average expression calculation. If not specified, it will use the\n`.X` slot of the `AnnData` objects. It is vital to set this correctly to avoid calculating\naverage expression on log1p-transformed data (default: None).\n)-&gt;Tuple: # A tuple containing the dot color values for query and target datasets, respectively.\n\nCalculate average expression in each cluster and translate that to dot color for the dotplot. Note that this function does not know what you did with the matrix before; if you have log-transformed the data it will calculate an average of logs, not the log of the exp-transformed average.\n\nsource\n\n\nget_dot_size\n\ndef get_dot_size(\n    query:DataFrame, # The query dataset.\n    target:DataFrame, # The target dataset.\n    query_clustering:str, # The .obs column name to use for the query dataset.\n    target_clustering:str, # The .obs column name to use for the target dataset.\n    query_genes:Optional=None, # Array of query genes to subset the data, if any. If None, use all genes (default: None).\n    target_genes:Optional=None, # Array of target genes to subset the data, if any. If None, use all genes (default: None).\n    query_gene_names:Optional=None, # Array of query gene names (default: None).\n    target_gene_names:Optional=None, # Array of target gene names (default: None).\n)-&gt;Tuple: # A tuple containing the dot size values for query and target datasets, respectively.\n\nCalculate which percentage of cells in each cluster express each gene, and translate that to dot size for the dotplot.\n\nsource\n\n\nfeature_colors\n\ndef feature_colors(\n    components:ndarray, # The array of components.\n    query_G:int, # The number of components for the query genes.\n    seed:int=42, # The seed value for the random number generator (default: 42).\n)-&gt;Tuple: # A tuple containing the colored components for query genes and target genes, respectively.\n\nAssign colors to the components based on the given array of components.\n\nsource\n\n\ngene_order\n\ndef gene_order(\n    full_adjacency:ndarray, # The full adjacency matrix represented as a 2D numpy array.\n    components:ndarray, # An array representing the components.\n    query_G:int, # The number of query genes.\n)-&gt;Tuple: # A tuple containing the query gene order and the target gene order as numpy arrays.\n\nCalculate the order of genes based on the given full adjacency matrix and components. Highly connected genes are placed first, genes without any connections are randomly ordered in the bottom of the plot.\n\nsource\n\n\ncalculate_adjacency_matrix\n\ndef calculate_adjacency_matrix(\n    connections:ndarray, # The 2D array representing the connections between genes. Each row contains two gene\nidentifiers indicating a connection, and optionally the strength of that connection.\n    query_genes:List, # A list of genes that act as queries.\n    target_genes:List, # A list of genes that act as targets.\n)-&gt;ndarray: # The adjacency matrix represented as a 2D numpy array. It has dimensions (query_G + target_G)\nx (query_G + target_G), where query_G and target_G are the lengths of query_genes and\ntarget_genes, respectively.\n\nCalculate the adjacency matrix based on the given connections, query genes, and target genes.\n\nsource\n\n\nlabel_pos\n\ndef label_pos(\n    display_coords:Dict, # A dictionary that holds the window extents of tick labels.\n    key:str, # The label to retrieve; a gene name.\n    side:str='left', # One of \"left\" or \"right\"; depending on orientation will return the leftmost or rightmost\nposition of the label (default: \"left\").\n)-&gt;Tuple: # A tuple containing the x and y coordinates of the label.\n\nGet the edge coordinates of a label. Keep either the left or the right end of the word.\n\nsource\n\n\nprepare_dotplot\n\ndef prepare_dotplot(\n    avg_expr:DataFrame, # Data frame that holds average expression for all genes and all clusters.\n    perc_expr:DataFrame, # Data frame that tracks the percentage of cells expressing each gene in every cluster.\n    cmap:Union='magma_r', # The Colormap instance or registered colormap name used to map scalar data to colors\n(default: \"magma_r\").\n    vmin:float=0, # Minimum average expression value to show (default: 0).\n    vmax:Optional=None, # Maximum average expression value to show (default: maximum average expr. value).\n    size_exponent:float=1.5, # Dot size is computed as fraction ** size_exponent * dot_size (default: 1.5).\n    dot_size:float=200, # The size of the largest dot (default: 200).\n)-&gt;Tuple: # A tuple containing the melted average expression data frame, the melted percentage\nexpression data frame, and the array of RGBA-coded color values for the average expression\nin a cluster/gene combination, according to the input color map.\n\nPivots average expression and percent expressed tables to make them dotplot-friendly.",
    "crumbs": [
      "dotplot_util"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ComAnDOS",
    "section": "",
    "text": "A draft is under preparation at comandos-paper.\n   \n\n\n\nAs a long-time user of SAMap and a connoisseur of cross-species comparisons, I was always frustrated by the lack of useful visualization downstream of SAMap results. We don’t need fancy software to figure out that ciliated cells are similar to ciliated cells, and muscle to muscle, but what about those pesky “unknown_sensory_2” and “ciliated?_2” clusters? ComAnDOS is a collection of plotting functions and assorted utilities that I hacked together to help myself and collaborators make sense of SAMap results. It is conceived as a SAMap add-on, but it doesn’t require it per se. It mostly works with two “primitives”: AnnData, and Pandas DataFrames, so it should be relatively easy to adapt to your use case.\nIt currently includes:\n\nfancy heatmaps (replace Sankey plots, circle plots)\npaired dotplots (directly compare cross-species expression!)\nassorted utility functions",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "index.html#publications",
    "href": "index.html#publications",
    "title": "ComAnDOS",
    "section": "",
    "text": "A draft is under preparation at comandos-paper.\n   \n\n\n\nAs a long-time user of SAMap and a connoisseur of cross-species comparisons, I was always frustrated by the lack of useful visualization downstream of SAMap results. We don’t need fancy software to figure out that ciliated cells are similar to ciliated cells, and muscle to muscle, but what about those pesky “unknown_sensory_2” and “ciliated?_2” clusters? ComAnDOS is a collection of plotting functions and assorted utilities that I hacked together to help myself and collaborators make sense of SAMap results. It is conceived as a SAMap add-on, but it doesn’t require it per se. It mostly works with two “primitives”: AnnData, and Pandas DataFrames, so it should be relatively easy to adapt to your use case.\nIt currently includes:\n\nfancy heatmaps (replace Sankey plots, circle plots)\npaired dotplots (directly compare cross-species expression!)\nassorted utility functions",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "index.html#background-and-motivation",
    "href": "index.html#background-and-motivation",
    "title": "ComAnDOS",
    "section": "Background and motivation",
    "text": "Background and motivation\n\n\nclick to expand\n\nSingle-cell RNA-seq (scRNA-seq) is a powerful tool to study the transcriptome of individual cells. As the technology matured, it became possible to use it on non-model organisms, facilitating cell type comparison across species. Early methods for this task subsetted gene expression matrices to one-to-one orthologous genes, assuming that sequence conservation also implies conservation of location, magnitude, and timing of gene expression. Not only is this assumption not true, but it also requires us to discard a large amount of data.\nSAMap was the first method to try and include many-to-one orthology relations. In alternating steps, it optimises a cell graph and a gene graph, using the former to inform the latter and vice versa. The result is a converged low-dimensional embedding that contains the cells of both species, allowing for direct comparison.\nSAMap comes with a small number of visualization tools, but, as I had to find out myself, they are not sufficient for in-depth analysis. In particular:\n\nSankey diagrams, SAMap’s default visualization for cluster-cluster relationships, obscure the fact that cell types are hierarchically organized. They also make it harder to quantify just how similar two cell types are according to SAMap.\nTarashansky et al. used network diagrams to demonstrate highly connected cell type families. I found that these diagrams are not very informative, as they are hard to read and do not scale well to large datasets.\nIn the publication, heatmaps are used once, but not to their full extent.\nOverlapping dimplots with corresponding violin plots are used to demonstrate co-expression across species. This is a good idea, but results in overloaded plots.\nThe authors use dotplots to show gene expression across species, color-coding the species. This loses one of the dotplots’ dimensions, where color usually encodes expression level, and forces the use of an additional axis to show expression magnitude. Furthermore, the relationships between the plotted genes in the different species are hard to visualize and need to be described in text.\n\nThese visualisations have two additional shortcomings: First, they are not easily reproducible, as they are not part of SAMap but rather custom solutions for very specific use cases. Second, they are extremely specific in what they show, and thus not useful for exploratory data analysis.",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "ComAnDOS",
    "section": "Documentation",
    "text": "Documentation\nThis package was developed using nbdev, which means the source code was generated from Jupyter notebooks using the literate programming paradigm. You can see the exported function signatures and assorted explanations online. I am currently working on tutorials for the most important use cases.\nFor questions or requests please open an issue on GitHub. I will be communicating updates, if any, on Twitter.\nExample data is available on Zenodo.\n\nAI use\nThis code was partly generated with GitHub’s CoPilot, which was used to fix bugs and correct linting/import/formatting issues via automatic suggestions. To the best of my knowledge, I mostly used ChatGPT 5-miniO.",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "ComAnDOS",
    "section": "Install",
    "text": "Install\nIt is good practice to set up a virtual environment for your Python projects. I recommend conda, or mamba if you want faster package installation; in both cases, please remember to not use normal Anaconda so as to avoid their licensing traps, and instead use whatever conda-forge are recommending.\nThe package was last tested with Python 3.14; it should work with Python&gt;3.9, but there are no guarantees.\nconda create -n comandos python=3.14\nconda activate comandos\n\nPyPi\npip install comandos\n\n\nGitHub\nOn the off-case you’d wish to make changes yourself:\npip install scanpy jupyterlab\nAfter installing dependencies, clone the latest version from GitHub and install it:\ncd /directory/of/choice\ngit clone https://github.com/galicae/comandos.git\ncd comandos\npip install -e .",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "ComAnDOS",
    "section": "Getting started",
    "text": "Getting started\n&lt;list example notebooks here&gt;",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "genes.html",
    "href": "genes.html",
    "title": "genes",
    "section": "",
    "text": "SAMap is built on pairwise gene similarity. For cross-species comparisons it is often very interesting to know the level of conservation of two genes - mostly, whether they are orthologs or paralogs. I will provide functions to annotate genes with orthology information from EggNOG-mapper, but you can also use your own orthology annotation, provided it returns the same thing: a \\(G_1\n\\times G_2\\) table where \\(G_1\\) and \\(G_2\\) are the genes in the two species you are comparing, and each cell \\((g_1, g_2)\\) contains the orthology relationship between \\(g_1\\) and \\(g_2\\): 2, if they are orthologs, 1 if they are paralogs/in the same gene family, 0 if they are unrelated.\nThis is an extremely inefficient way of saving this matrix, and it would be relatively easy to code this as a sparse matrix, but I don’t think it’s worth the effort. The matrices are not too large (especially after the gene filtering that is so common to scRNA-seq analysis), and even home computers commonly pack 16GB of RAM these days. Unless you are working with Frankenstein’d genomes with tens of thousands of “genes” you will be fine.\nFirst we will need to read in the EggNOG-mapper result file.\n\n\n\nWARNING - EggNOG format:\n\nDepending on the version of EggNOG you may get a slightly different file; you will need to filter it down to the two columns we need: the query gene ID and the orthogroup assignments. These are a comma-separated string in the format orthogroup_ID@taxonomic_level. The taxonomic level will determine whether genes are orthologs or paralogs, so choose wisely. I am using \"Eukaryota\" and \"Bilateria\" as defaults, but it may well be that your version of EggNOG is using NCBI taxonomic IDs instead of verbose names. Please check before applying!\n\n\n\n\n\nWARNING - Index matching:\n\nFor the entries of the EggNOG table to match to the gene names in the SAMap object we need to make sure the index of query matches to the index of sm.sams[query_species].adata.var. If you created the files in the scheme that I am following, this means that you prepended the species ID to the gene IDs; we would need to do the same here.\n\n\n\nquery = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"eggnog/hydra.tsv\",\n    sep=\"\\t\",\n    engine=\"python\",\n)\nquery = query[\n    [\"Unnamed: 0\", \"eggNOG_OGs\"]\n].copy()  # I am only keeping the columns I need\nquery.columns = [\"gene_id\", \"eggNOG_OGs\"]  # rename so that it is easier to work with\nquery[\"gene_id\"] = \"hy_\" + query[\"gene_id\"].astype(str)\n\n\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 query = pd.read_csv(\n      2     os.environ[\"EXAMPLE_DATA_PATH\"] + \"eggnog/hydra.tsv\",\n      3     sep=\"\\t\",\n      4     engine=\"python\",\n      5 )\n      6 query = query[\n      7     [\"Unnamed: 0\", \"eggNOG_OGs\"]\n      8 ].copy()  # I am only keeping the columns I need\n      9 query.columns = [\"gene_id\", \"eggNOG_OGs\"]  # rename so that it is easier to work with\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/pandas/io/parsers/readers.py:1026, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\n   1013 kwds_defaults = _refine_defaults_read(\n   1014     dialect,\n   1015     delimiter,\n   (...)   1022     dtype_backend=dtype_backend,\n   1023 )\n   1024 kwds.update(kwds_defaults)\n-&gt; 1026 return _read(filepath_or_buffer, kwds)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/pandas/io/parsers/readers.py:620, in _read(filepath_or_buffer, kwds)\n    617 _validate_names(kwds.get(\"names\", None))\n    619 # Create the parser.\n--&gt; 620 parser = TextFileReader(filepath_or_buffer, **kwds)\n    622 if chunksize or iterator:\n    623     return parser\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/pandas/io/parsers/readers.py:1620, in TextFileReader.__init__(self, f, engine, **kwds)\n   1617     self.options[\"has_index_names\"] = kwds[\"has_index_names\"]\n   1619 self.handles: IOHandles | None = None\n-&gt; 1620 self._engine = self._make_engine(f, self.engine)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/pandas/io/parsers/readers.py:1880, in TextFileReader._make_engine(self, f, engine)\n   1878     if \"b\" not in mode:\n   1879         mode += \"b\"\n-&gt; 1880 self.handles = get_handle(\n   1881     f,\n   1882     mode,\n   1883     encoding=self.options.get(\"encoding\", None),\n   1884     compression=self.options.get(\"compression\", None),\n   1885     memory_map=self.options.get(\"memory_map\", False),\n   1886     is_text=is_text,\n   1887     errors=self.options.get(\"encoding_errors\", \"strict\"),\n   1888     storage_options=self.options.get(\"storage_options\", None),\n   1889 )\n   1890 assert self.handles is not None\n   1891 f = self.handles.handle\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/pandas/io/common.py:873, in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\n    868 elif isinstance(handle, str):\n    869     # Check whether the filename is to be opened in binary mode.\n    870     # Binary mode does not support 'encoding' and 'newline'.\n    871     if ioargs.encoding and \"b\" not in ioargs.mode:\n    872         # Encoding\n--&gt; 873         handle = open(\n    874             handle,\n    875             ioargs.mode,\n    876             encoding=ioargs.encoding,\n    877             errors=errors,\n    878             newline=\"\",\n    879         )\n    880     else:\n    881         # Binary mode\n    882         handle = open(handle, ioargs.mode)\n\nFileNotFoundError: [Errno 2] No such file or directory: '/Users/npapadop/Documents/repos/comandos/example_data/eggnog/hydra.tsv'\n\n\n\n\nquery\n\n\n\n\n\n\n\n\ngene_id\neggNOG_OGs\n\n\n\n\n0\nhy_t33417aep\n38ERC@33154,3NUD8@4751,3QR2W@4890,3RR2D@4891,C...\n\n\n1\nhy_t33418aep\n2CN11@1,2QT83@2759,38D3X@33154,3BDRF@33208,3CX...\n\n\n2\nhy_t37645aep\n38CHP@33154,3B9GY@33208,COG2124@1,KOG0157@2759\n\n\n3\nhy_t31628aep\nKOG1075@1,KOG1075@2759,KOG4475@1,KOG4475@2759\n\n\n4\nhy_t33265aep\n3QB9P@4776,COG3145@1,KOG2731@2759\n\n\n...\n...\n...\n\n\n18265\nhy_t24932aep\n3A1BV@33154,3BQ1H@33208,KOG1121@1,KOG1121@2759\n\n\n18266\nhy_t24930aep\n2E9XV@1,2SG7Z@2759\n\n\n18267\nhy_t24940aep\nKOG0118@1,KOG0118@2759\n\n\n18268\nhy_t29557aep\n2CZA0@1,2S9AH@2759,3ABW2@33154,3BVK1@33208\n\n\n18269\nhy_t29564aep\nCOG2340@1,KOG3017@2759\n\n\n\n\n18270 rows × 2 columns\n\n\n\nNow we will filter the EggNOG_OGs column and only keep the two levels that we’re interested in. Since we are comparing Hydra to a planarian we should be using the Metazoa level for orthologs. We can see from the table visualization that this table uses NCBI tax IDs, so we should look up the tax ID for Metazoa (33208). Similarly, if we would like to use the Eukaryota level for paralogs, we need its tax ID (2759).\nWe also need a function that will filter the orthology table to only keep the OGs that belong to the specified levels:\n\nsource\n\nfilter_OGs\n\ndef filter_OGs(\n    x:Union, paralog:str='Eukaryota', # the level of the paralog OG\n    ortholog:str='Bilateria', # the level of the ortholog OG\n)-&gt;list: # the paralog OG and ortholog OG\n\nFind the EggNOG OGs at the the paralog and ortholog level.\nThis function will filter one EggNOG string (or list) to the specified levels.\n\nquery[\"eggNOG_OGs\"].loc[0]\n\n'38ERC@33154,3NUD8@4751,3QR2W@4890,3RR2D@4891,COG5050@1,KOG2877@2759'\n\n\n\ninput_str = query[\"eggNOG_OGs\"].loc[0]\nparalog_str, ortholog_str = filter_OGs(input_str, paralog=\"2759\", ortholog=\"33208\")\nassert paralog_str == \"KOG2877@2759\"\nassert ortholog_str == \"\"\n\n\ninput_list = query[\"eggNOG_OGs\"].loc[0].split(\",\")\nparalog_list, ortholog_list = filter_OGs(input_list, paralog=\"2759\", ortholog=\"33208\")\nassert paralog_list == \"KOG2877@2759\"\nassert ortholog_list == \"\"\n\n\nsource\n\n\nassign_homology\n\ndef assign_homology(\n    species_OGs, # the dataframe with the gene_id and the EggNOG OGs\n    paralog:str='Eukaryota', # the level of the paralog OG\n    ortholog:str='Bilateria', # the level of the ortholog OG)\n)-&gt;DataFrame: # the dataframe with the gene_id, paralog OG and ortholog OG\n\nGet the taxonomy of the genes.\n\nhydra_genes = assign_homology(query, paralog=\"2759\", ortholog=\"33208\")\n\n\nhydra_genes\n\n\n\n\n\n\n\n\northolog\nparalog\n\n\ngene_id\n\n\n\n\n\n\nhy_t10003aep\n3BCY5@33208\nKOG3599@2759\n\n\nhy_t10008aep\nNone\nKOG1075@2759\n\n\nhy_t10009aep\n3BA48@33208\nKOG1545@2759\n\n\nhy_t10011aep\n3BFGW@33208\nKOG1136@2759\n\n\nhy_t10012aep\n3BKRE@33208\nKOG2527@2759\n\n\n...\n...\n...\n\n\nhy_t998aep\n3C06S@33208\n2S418@2759\n\n\nhy_t9990aep\nNone\nKOG0490@2759\n\n\nhy_t9992aep\n3B9JS@33208\nKOG0573@2759\n\n\nhy_t999aep\nNone\n2RZ1Z@2759\n\n\nhy_t99aep\n3BH2P@33208\nKOG2861@2759\n\n\n\n\n18270 rows × 2 columns\n\n\n\n\nassert hydra_genes.at[\"hy_t10003aep\", \"paralog\"] == \"KOG3599@2759\"\nassert hydra_genes.at[\"hy_t10003aep\", \"ortholog\"] == \"3BCY5@33208\"\n\nRepeat for the target species (planarian):\n\ntarget = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"eggnog/planarian.tsv\",\n    sep=\"\\t\",\n    engine=\"python\",\n)\ntarget = target[\n    [\"Unnamed: 0\", \"eggNOG_OGs\"]\n].copy()  # I am only keeping the columns I need\ntarget.columns = [\"gene_id\", \"eggNOG_OGs\"]  # rename so that it is easier to work with\ntarget[\"gene_id\"] = \"pl_\" + target[\"gene_id\"].astype(str)\n\nplanarian_genes = assign_homology(target, paralog=\"2759\", ortholog=\"33208\")\n\nGiven the orthology assignments (orthogroup membership), it is now very easy to calculate which cross-species genes are orthologs or paralogs; we just need to compare the columns of the orthology tables and keep score.\n\nsource\n\n\ncalculate_orthology_score\n\ndef calculate_orthology_score(\n    query:DataFrame, # the dataframe with the gene_id, paralog OG and ortholog OG for the query species\n    target:DataFrame\n)-&gt;DataFrame:\n\n\northology_score = calculate_orthology_score(hydra_genes, planarian_genes)\n\n\ngene1 = \"pl_dd_Smed_v4_10002_0_1\"\ngene2 = \"hy_t25984aep\"\n\nannot1 = target.set_index(\"gene_id\").loc[gene1]\nannot2 = query.set_index(\"gene_id\").loc[gene2]\n\nprint(annot1[\"eggNOG_OGs\"])\nprint(annot2[\"eggNOG_OGs\"])\n\n38GXK@33154,3BHNW@33208,3CZKV@33213,47ZE5@7711,48WIG@7742,4CF02@8459,KOG2397@1,KOG2397@2759\n38GXK@33154,3BHNW@33208,KOG2397@1,KOG2397@2759\n\n\nThese genes are orthologs, we should therefore expect them to have an orthology score of 2:\n\nassert orthology_score[gene1].loc[gene2] == 2\n\nWe can save the orthology table to disk for later use:\n# not run\northology_score.to_csv(\"path/to/hypl_orthology.tsv\", sep=\"\\t\")\n\nsource\n\n\nget_orthologs_overlap\n\ndef get_orthologs_overlap(\n    genes1, # A series of gene names.\n    genes2, # A series of gene names.\n    query, # An AnnData object containing the query genes as indices of the `.var` slot.\n    target, # An AnnData object containing the target genes as indices of the `.var` slot.\n    orthology, # A DataFrame containing the orthology information.\n): # A DataFrame of homologous gene pairs and their degree of conservation. The array has\nthree columns: 'query', 'target', and 'degree', where 'query' and 'target' are the gene\nnames, and 'degree' is the degree of conservation, which can be either 1 or 2.\n\nReturns a DataFrame of homologous gene pairs between two sets of genes based on their presence in an orthology table.\n\nsource\n\n\nget_orthologs\n\ndef get_orthologs(\n    genes:ndarray, # Array of gene names.\n    orthology:DataFrame, # Data frame representing the orthology information. The index should contain the query genes,\nthe columns should overlap with the index of target.var, and the values should be 1 for\nparalogs and 2 for orthologs.\n    target:AnnData, # Target annotation data.\n    celltype_to:str, # The target cell type. Must be a key in `target.uns[\"rank_genes_groups\"][\"names\"]`.\n)-&gt;ndarray: # Array of connections between genes, including orthologous and paralogous connections.\nColumns are (query, target, degree), where degree is 1 for paralogs and 2 for orthologs.\n\nGet orthologous and paralogous gene connections based on the given genes and orthology information.",
    "crumbs": [
      "genes"
    ]
  },
  {
    "objectID": "util.html",
    "href": "util.html",
    "title": "util",
    "section": "",
    "text": "source\n\nprocrustes\n\ndef procrustes(\n    x:str, # input string\n    appropriate_length:int=50, # desired length\n    pad_with:str=' ', # character to pad with\n    side:str='right', # which side to pad on (\"left\", \"right\")\n)-&gt;str: # string with desired length\n\nA function to regulate string length.\nWe are primarily going to be working with non-model species, so the gene names will always be of the form\nXLOC_123456 | emapper-name-or-description-if-we're-lucky\nor something similar. This means that we could have extreme variation in the actual length of a gene “name”; this will make it very hard to put gene names on axes as it will distort figure sizes. I wrote a function to either trim or pad strings; even though axis labels are not in monospace fonts, it is much easier to visually reconcile strings with lengths in the same order of magnitude.\n\ntoo_short = \"Niko\"\njust_right = \"Theseus\"\ntoo_tall = \"The Mountain\"\n\n\nassert procrustes(just_right, appropriate_length=7) == \"Theseus\"\nassert procrustes(too_short, appropriate_length=7) == \"Niko   \"\nassert procrustes(too_tall, appropriate_length=7) == \"The Mou\"\n\n\nsource\n\n\ngrouped_obs_mean\n\ndef grouped_obs_mean(\n    adata:AnnData, # AnnData object to analyse\n    group_key:str, # `.obs` category to group by\n    layer:Optional=None, # layer to use. If none, use `.X`\n)-&gt;DataFrame: # a groups$\\times$genes dataframe with the average expression\n\nHelper function to calculate average expression per group in an AnnData object.\nMany tasks in single-cell analysis require us to know the average expression of a gene in a certain group of cells. While scanpy does perform that task behind the scenes for, e.g. dotplots, this is not functionality that is exposed to the users. This is an implementation based on ivirshup’s answer to a scanpy issue.\n\nadata = sc.read_h5ad(os.environ[\"EXAMPLE_DATA_PATH\"] + \"hydra.h5ad\")\n\ncluster_means = grouped_obs_mean(adata, group_key=\"Cluster\")\n\nIf \\(G\\) is the number of genes and \\(C\\) the number of unique clusters in the group_key, the returned array should have the shape \\(G \\times C\\):\n\nno_genes = adata.shape[1]\nno_clusters = len(np.unique(adata.obs[\"Cluster\"]))\nassert cluster_means.shape == (no_genes, no_clusters)\n\nAdditionally, each column of the array should contain the average detected expression for cells in that cluster:\n\nbelong_to_ecEp_SC2 = adata.obs[\"Cluster\"] == \"ecEp_SC2\"\necEp_SC2_average = np.mean(adata[belong_to_ecEp_SC2].X, axis=0)\necEp_SC2_average = np.array(ecEp_SC2_average)[0]\n\nassert all(np.isclose(cluster_means[\"ecEp_SC2\"], ecEp_SC2_average))\n\n\nsource\n\n\ngrouped_obs_present\n\ndef grouped_obs_present(\n    adata, # AnnData object to analyse.\n    group_key, # `.obs` category to group by.\n    layer:Optional=None, # Layer to use. If none, use `.X`.\n): # A clusters$     imes$genes dataframe with the number of expressing cells per cluster.\n\nHelper function to calculate how many cells express each gene per group in an AnnData object.\nAnother critical value to know when making dotplots is the fraction of cells expressing a gene in a certain cluster. Again, scanpy performs that task without exposing it to the users. Similar to [grouped_obs_mean](https://galicae.github.io/comandos/util.html#grouped_obs_mean) this is an implementation based on ivirshup’s answer to a scanpy issue. Here we calculate the sum of cells expressing a gene, a table we can use to calculate the fraction later.\n\nnum_expressing = grouped_obs_present(adata, group_key=\"Cluster\")\n\nIf \\(G\\) is the number of genes and \\(C\\) the number of unique clusters in the group_key, the returned array should have the shape \\(G \\times C\\):\n\nassert num_expressing.shape == (no_genes, no_clusters)\n\nAdditionally, each column of the array should contain the percentage of cells expressing each gene in that cluster:\n\nbelong_to_ecEp_SC2 = adata.obs[\"Cluster\"] == \"ecEp_SC2\"\necEp_SC2_expr = np.sum(adata[belong_to_ecEp_SC2].X &gt; 0, axis=0)\necEp_SC2_expr = np.array(ecEp_SC2_expr)[0]\n\nassert all(num_expressing[\"ecEp_SC2\"] == ecEp_SC2_expr)\n\n\nsource\n\n\ngrouped_obs_percent\n\ndef grouped_obs_percent(\n    adata, # AnnData object to analyse.\n    group_key, # `.obs` category to group by.\n    layer:Optional=None, # Layer to use. If none, use `.X`.\n): # A clusters$     imes$genes dataframe with the percentage of expressing cells per cluster.\n\nHelper function to calculate what percentage of cells express each gene per group in an AnnData object.\nCalculating the fraction of cells is of course very straightforward once we have counted the number of cells that express the gene as well as the total number of cells in a cluster.\n\nfrac_expressing = grouped_obs_percent(adata, group_key=\"Cluster\")\n# use the counts and number of cells we calculated before\nfrac_ecEp_SC2 = ecEp_SC2_expr / np.sum(belong_to_ecEp_SC2)\n\nassert all(np.isclose(frac_expressing[\"ecEp_SC2\"], frac_ecEp_SC2))\n\nWhen visualising gene expression in the context of single-cell RNA-seq comparisons between species, absolute expression values are meaningless, as there are too many factors that determine them that we can not account for. It is sometimes more informative to look at the relative expression of a gene within the organism, i.e. to look at it in terms of min/max expression.\nScanpy does not have a provision for this, so here is a small utility function that does that:\n\nsource\n\n\nrescale\n\ndef rescale(\n    x:DataFrame, # A two-dimensional array to rescale; preferably the output of [`grouped_obs_mean`](https://galicae.github.io/comandos/util.html#grouped_obs_mean).\n)-&gt;DataFrame: # the rescaled dataframe.\n\nRescale a dataframe so that row values are in the range [0, 1].\n\n\nHighlighting clusters\nDimensionality reduction plots can often be rather busy, and searching for the correct cluster can be a bit of a hassle. It would be great if we could highlight the cluster of interest without losing the rest of the clustering information; for instance by drawing a circle around the cluster to highlight.\n\nsource\n\n\nfind_center\n\ndef find_center(\n    coords, # A 2D array with X, Y-coordinates from xs, ys.\n): # The X-coordinate of the mode.\n\nA function that estimates a Gaussian probability density for the input data and returns the mode. From https://stackoverflow.com/a/60185876.\nA heuristic to achieve this is to pretend the cluster points are a Gaussian cloud on UMAP/tSNE/PCA/&lt;your favorite embedding&gt; space, and take the position with the highest density (the mode of the 2D distribution). This function is inspired from a StackOverflow answer, and mostly a wrapper around the Gaussian KDE function from scikit-learn.\n\n# create a random number generator\nrng = np.random.default_rng(42)\n# create a 2D Gaussian dataset\nx = rng.normal(loc=2, scale=1, size=2000)\ny = rng.normal(loc=-2, scale=1, size=2000)\n\ncoords = np.array([x, y]).T\n\n\ncoords_center = find_center(coords)\n\nWe’d expect the mode of the kernel density estimate to be very close to the true mean of the data. Since this is for plotting purposes we don’t need to be extremely specific. See plot:highlighted_dimplot for a demonstration of the function.\n\nassert np.isclose(coords_center[0], 2, rtol=0.2)\nassert np.isclose(coords_center[1], -2, rtol=0.2)\n\n\nsource\n\n\nmap_fine_to_coarse\n\ndef map_fine_to_coarse(\n    sm, # SAMAP object to process.\n    species, # Species ID of the correct SAM object.\n    fine, # Fine clustering slot name.\n    coarse:NoneType=None, # Coarse clustering slot name. If None, use the same as `fine`, mapping each cluster to\nitself. (default: `None`).\n    plot:function=umap, # Plotting function to use; this will correctly set the colors (default: `sc.pl.umap`).\n    include_coarse:bool=False, # If True, preface the fine cluster names with the coarse cluster names (default: `False`).\n): # A dataframe with the mapping of fine to coarse clusters.\n\nExtract the mapping of fine to coarse clusters from a SAMap object.\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/fastcore/docscrape.py:259: UserWarning: potentially wrong underline length... \nModifies \n------- in \nThis function collapses unrelated clusters by identifying a major cluster category based on the\n`coarse` column. It then assigns the major cluster category to all unrelated clusters in the...\n  else: warn(msg)\n\nsource\n\n\ncollapse_unrelated_clusters\n\ndef collapse_unrelated_clusters(\n    adata:AnnData, # The annotation data containing the clusters to be collapsed.\n    cluster:str, # The cluster identifier within the `fine` column that needs to be collapsed.\n    fine:str, # The column name representing the fine-grained clustering.\n    coarse:str, # The column name representing the coarse-grained clustering.\n)-&gt;None:\n\nThis function collapses unrelated clusters by identifying a major cluster category based on the coarse column. It then assigns the major cluster category to all unrelated clusters in the fine column. The resulting collapsed cluster information is stored in a new column named fine + \"_collapsed\".\n\nfile = open(os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl.pkl\", \"rb\")\nsm = pickle.load(file)\n\nsm.sams[\"hy\"].adata.obs[\"coarse\"] = (\n    sm.sams[\"hy\"].adata.obs[\"Cluster\"].str.split(\"_\").str[0]\n)\n\n\ncollapse_unrelated_clusters(sm.sams[\"hy\"].adata, \"ecEp_SC2\", \"Cluster\", \"coarse\")\n\n\nsm.sams[\"hy\"].adata.obs[\"Cluster\"].cat.categories\n\nIndex(['ecEp_SC2', 'ecEp_SC3', 'ecEp_bat1(mp)', 'ecEp_bat2(mp)', 'ecEp_bd',\n       'ecEp_head', 'ecEp_nem1(pd)', 'ecEp_nem2(id)', 'enEp_SC1', 'enEp_SC2',\n       'enEp_SC3', 'enEp_foot', 'enEp_head', 'enEp_nem1(pd)', 'enEp_nem2(pd)',\n       'enEp_tent', 'enEp_tent(pd)', 'i_SC', 'i_fmgl1', 'i_fmgl2_nurse',\n       'i_gmgc', 'i_mgl', 'i_nb1', 'i_nb2', 'i_nb3', 'i_nb4', 'i_nc1', 'i_nc2',\n       'i_nc3', 'i_nc4', 'i_nc5', 'i_nc6', 'i_nc7', 'i_nc8', 'i_nc_gc_prog',\n       'i_nc_prog', 'i_nem', 'i_smgc1', 'i_smgc2', 'i_zmg1', 'i_zmg2', 'nan'],\n      dtype='object')\n\n\n\nsm.sams[\"hy\"].adata.obs[\"Cluster_collapsed\"].cat.categories\n\nIndex(['ecEp_SC2', 'ecEp_SC3', 'ecEp_bat1(mp)', 'ecEp_bat2(mp)', 'ecEp_bd',\n       'ecEp_head', 'ecEp_nem1(pd)', 'ecEp_nem2(id)', 'enEp', 'i', 'nan'],\n      dtype='object')\n\n\nNotice that all subclusters in the \"ecEP\" group are still visible, but all other clusters are subsumed by their coarse cluster.",
    "crumbs": [
      "util"
    ]
  },
  {
    "objectID": "plot.html",
    "href": "plot.html",
    "title": "plot",
    "section": "",
    "text": "These functions are intended to help you find your way around the data. I use them a lot when generating reports for collaborators, to set the stage for the more detailed analyses. In particular, I want to highlight which clusters we are comparing and where they are in the context of both species as well as the comparison.\n\nsource\n\n\n\ndef highlighted_dimplot(\n    adata:AnnData, # AnnData object to plot.\n    species:str, # Species name. Will be used in the title, and removed from the cluster names if present.\n    clustering:str, # Clustering to plot. Must be present in `adata.obs`.\n    cluster:str, # Cluster to highlight.\n    embedding:str='X_umap', # Embedding to plot (default: \"X_umap\").\n    highlight:str='red', # Color of the circle (default: \"red\").\n    figsize:tuple=(10, 10), # Figure size (default: (10, 10)).\n    save:Optional=None, # Path to save the figure (default: None).\n):\n\nPlot a low-dimensional embedding and highlight a chosen cluster with a superimposed circle.\n\nplanarian = sc.read_h5ad(os.environ[\"EXAMPLE_DATA_PATH\"] + \"planarian.h5ad\")\nplanarian.var.index = \"pl_\" + planarian.var.index\n\n\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 planarian = sc.read_h5ad(os.environ[\"EXAMPLE_DATA_PATH\"] + \"planarian.h5ad\")\n      2 planarian.var.index = \"pl_\" + planarian.var.index\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/anndata/_io/h5ad.py:263, in read_h5ad(filename, backed, as_sparse, as_sparse_fmt, chunk_size)\n    257         raise NotImplementedError(msg)\n    259 rdasp = partial(\n    260     read_dense_as_sparse, sparse_format=as_sparse_fmt, axis_chunk=chunk_size\n    261 )\n--&gt; 263 with h5py.File(filename, \"r\") as f:\n    265     def callback(read_func, elem_name: str, elem: StorageType, iospec: IOSpec):\n    266         if iospec.encoding_type == \"anndata\" or elem_name.endswith(\"/\"):\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/h5py/_hl/files.py:566, in File.__init__(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, track_times, **kwds)\n    557     fapl = make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n    558                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n    559                      alignment_threshold=alignment_threshold,\n    560                      alignment_interval=alignment_interval,\n    561                      meta_block_size=meta_block_size,\n    562                      **kwds)\n    563     fcpl = make_fcpl(track_order=track_order, track_times=track_times,\n    564                      fs_strategy=fs_strategy, fs_persist=fs_persist,\n    565                      fs_threshold=fs_threshold, fs_page_size=fs_page_size)\n--&gt; 566     fid = make_fid(name, mode, userblock_size, fapl, fcpl, swmr=swmr)\n    568 if isinstance(libver, tuple):\n    569     self._libver = libver\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/h5py/_hl/files.py:241, in make_fid(name, mode, userblock_size, fapl, fcpl, swmr)\n    239     if swmr and swmr_support:\n    240         flags |= h5f.ACC_SWMR_READ\n--&gt; 241     fid = h5f.open(name, flags, fapl=fapl)\n    242 elif mode == 'r+':\n    243     fid = h5f.open(name, h5f.ACC_RDWR, fapl=fapl)\n\nFile h5py/_objects.pyx:54, in h5py._objects.with_phil.wrapper()\n\nFile h5py/_objects.pyx:55, in h5py._objects.with_phil.wrapper()\n\nFile h5py/h5f.pyx:104, in h5py.h5f.open()\n\nFileNotFoundError: [Errno 2] Unable to synchronously open file (unable to open file: name = '/Users/npapadop/Documents/repos/comandos/example_data/planarian.h5ad', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)\n\n\n\n\nhighlighted_dimplot(planarian, \"Smed\", \"tissue\", \"Pharynx\", figsize=(6, 6))\n\nOf course, if a cluster is too spread out, the plot will not work as well, but it will still be useful to see the general location of the cluster.\n\nhighlighted_dimplot(planarian, \"Smed\", \"tissue\", \"Neural\", figsize=(6, 6))\n\nAnother case that might not work so well is if the shape of a cluster is not Gaussian. Still, it should help us spot the cluster, especially if the color contrasts enough.\n\nhighlighted_dimplot(\n    planarian, \"Smed\", \"tissue\", \"Muscle\", figsize=(6, 6), highlight=\"lightgreen\"\n)\n\n\nsource\n\n\n\n\ndef highlighted_heatmap(\n    to_plot, # A dataframe of pairwise similarities between cell types.\n    celltype_from, # Cell type of the query species to highlight. Must be in `to_plot.columns`.\n    celltype_to, # Cell type of the target species to highlight. Must be in `to_plot.index`.\n    figheight:int=20, # Height of the resulting plot in inches. Width will be calculated automatically (default:\n20).\n    save:NoneType=None, # Path to result figure; if None, the figure will be plotted but not saved (default: None).\n):\n\nPlot a heatmap of pairwise similarities between cell types, with a red box highlighting the query cell type.\n\nhysc = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"hysc_similarity_table.csv\",\n    index_col=0,\n)\n\n\nhighlighted_heatmap(\n    hysc, celltype_from=\"hy_i_SC\", celltype_to=\"sc_Neoblast: 0\", figheight=12\n)\n\n\nsource\n\n\n\n\ndef annotated_heatmap(\n    sm:SAMAP, # SAMAP object\n    similarity:DataFrame, # Similarity matrix. Contains query species clusters as columns and target species clusters as rows.\n    query_species:str, # Query species ID. Will be used in the title. Should prepend the similarity matrix column names.\n    target_species:str, # Target species ID. Will be used in the title. Should prepend the similarity matrix row names.\n    query_clustering:str, # Query species clustering. Must be present in `sm.sams[query_species].adata.obs`.\n    target_clustering:str, # Target species clustering. Must be present in `sm.sams[target_species].adata.obs`.\n    query_coarse:Optional=None,\n    target_coarse:Optional=None, # Query species coarse clustering. Must be present in `sm.sams[query_species].adata.obs`. If None, will be set to `query_clustering` (default: None).\n    interactive:bool=False, # If True, will return a plotly figure. Otherwise, will return a matplotlib figure (default: False).\n    figsize:Optional=None,\n    save:Optional=None, # Figure size. If None, will be guessed from the size of the similarity matrix (default: None).\n    kwargs:Any\n)-&gt;Optional: # If not None, will save the figure to the specified path (default: None).\nAdditional arguments to pass to `seaborn.heatmap` (matplotlib) or `plotly.graph_objects.Figure` (plotly). Among them: dpi (int), which is only used if `interactive=True` to set the figure size in pixels.\n\nPlot the similarity matrix as an annotated heatmap.\nRead the requisite files: the SAMap object and the pairwise cluster similarity matrix.\n\nfile = open(os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl.pkl\", \"rb\")\nsm = pickle.load(file)\n\nhypl = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl_similarity_table.csv\",\n    index_col=0,\n)\n\nFirst improve the coarse level assignments for the data we have here:\n\nsm.sams[\"hy\"].adata.obs[\"coarse\"] = (\n    sm.sams[\"hy\"].adata.obs[\"Cluster\"].str.split(\"_\").str[0]\n)\nsm.sams[\"pl\"].adata.obs[\"coarse\"] = (\n    sm.sams[\"pl\"].adata.obs[\"tissue_smedwi\"].str.split(\"_\").str[0]\n)\n\n\nannotated_heatmap(\n    sm,\n    hypl,\n    \"hy\",\n    \"pl\",\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_coarse=\"coarse\",\n    target_coarse=\"coarse\",\n    interactive=False,\n    save=\"hypl.pdf\",\n)\n\nThis sort of plot does a much better job of showing the relationships between clusters than the Sankey diagram. Clear patches of similarity emerge that would be otherwise invisible. This is a result of the hierarchical relationship between cell types (see Arendt/Musser/Wagner in 2016 and 2019). By combining maps like this with the per-species cell type family trees we can start to get a better idea of how cell types may have evolved over time.\n\nassert os.path.exists(\"hypl.pdf\")\n\nWe can make the same plot in interactive form. Unfortunately, the interactive version is a bit more finicky with color usage, so for now I’ll let plotly choose the colors, but any plotly wizards out there are welcome to improve this. Right now hovering over a point will show the cluster names and SAMap score; hovering over the colored bars at the margins should show the coarse cluster.\n\nplotly_overview = annotated_heatmap(\n    sm,\n    hypl,\n    \"hy\",\n    \"pl\",\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_coarse=\"coarse\",\n    target_coarse=\"coarse\",\n    figsize=(10, 10),\n    interactive=True,\n    dpi=100,\n    save=\"hypl\",\n)\n\n\nassert os.path.exists(\"hypl.json\")\nassert os.path.exists(\"hypl.html\")\n\nYou can visualize the plot in a notebook with:\n# not run\nplotly_overview.show()",
    "crumbs": [
      "plot"
    ]
  },
  {
    "objectID": "plot.html#see-the-big-picture",
    "href": "plot.html#see-the-big-picture",
    "title": "plot",
    "section": "",
    "text": "These functions are intended to help you find your way around the data. I use them a lot when generating reports for collaborators, to set the stage for the more detailed analyses. In particular, I want to highlight which clusters we are comparing and where they are in the context of both species as well as the comparison.\n\nsource\n\n\n\ndef highlighted_dimplot(\n    adata:AnnData, # AnnData object to plot.\n    species:str, # Species name. Will be used in the title, and removed from the cluster names if present.\n    clustering:str, # Clustering to plot. Must be present in `adata.obs`.\n    cluster:str, # Cluster to highlight.\n    embedding:str='X_umap', # Embedding to plot (default: \"X_umap\").\n    highlight:str='red', # Color of the circle (default: \"red\").\n    figsize:tuple=(10, 10), # Figure size (default: (10, 10)).\n    save:Optional=None, # Path to save the figure (default: None).\n):\n\nPlot a low-dimensional embedding and highlight a chosen cluster with a superimposed circle.\n\nplanarian = sc.read_h5ad(os.environ[\"EXAMPLE_DATA_PATH\"] + \"planarian.h5ad\")\nplanarian.var.index = \"pl_\" + planarian.var.index\n\n\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 planarian = sc.read_h5ad(os.environ[\"EXAMPLE_DATA_PATH\"] + \"planarian.h5ad\")\n      2 planarian.var.index = \"pl_\" + planarian.var.index\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/anndata/_io/h5ad.py:263, in read_h5ad(filename, backed, as_sparse, as_sparse_fmt, chunk_size)\n    257         raise NotImplementedError(msg)\n    259 rdasp = partial(\n    260     read_dense_as_sparse, sparse_format=as_sparse_fmt, axis_chunk=chunk_size\n    261 )\n--&gt; 263 with h5py.File(filename, \"r\") as f:\n    265     def callback(read_func, elem_name: str, elem: StorageType, iospec: IOSpec):\n    266         if iospec.encoding_type == \"anndata\" or elem_name.endswith(\"/\"):\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/h5py/_hl/files.py:566, in File.__init__(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, fs_page_size, page_buf_size, min_meta_keep, min_raw_keep, locking, alignment_threshold, alignment_interval, meta_block_size, track_times, **kwds)\n    557     fapl = make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0,\n    558                      locking, page_buf_size, min_meta_keep, min_raw_keep,\n    559                      alignment_threshold=alignment_threshold,\n    560                      alignment_interval=alignment_interval,\n    561                      meta_block_size=meta_block_size,\n    562                      **kwds)\n    563     fcpl = make_fcpl(track_order=track_order, track_times=track_times,\n    564                      fs_strategy=fs_strategy, fs_persist=fs_persist,\n    565                      fs_threshold=fs_threshold, fs_page_size=fs_page_size)\n--&gt; 566     fid = make_fid(name, mode, userblock_size, fapl, fcpl, swmr=swmr)\n    568 if isinstance(libver, tuple):\n    569     self._libver = libver\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/comandos_dev/lib/python3.14/site-packages/h5py/_hl/files.py:241, in make_fid(name, mode, userblock_size, fapl, fcpl, swmr)\n    239     if swmr and swmr_support:\n    240         flags |= h5f.ACC_SWMR_READ\n--&gt; 241     fid = h5f.open(name, flags, fapl=fapl)\n    242 elif mode == 'r+':\n    243     fid = h5f.open(name, h5f.ACC_RDWR, fapl=fapl)\n\nFile h5py/_objects.pyx:54, in h5py._objects.with_phil.wrapper()\n\nFile h5py/_objects.pyx:55, in h5py._objects.with_phil.wrapper()\n\nFile h5py/h5f.pyx:104, in h5py.h5f.open()\n\nFileNotFoundError: [Errno 2] Unable to synchronously open file (unable to open file: name = '/Users/npapadop/Documents/repos/comandos/example_data/planarian.h5ad', errno = 2, error message = 'No such file or directory', flags = 0, o_flags = 0)\n\n\n\n\nhighlighted_dimplot(planarian, \"Smed\", \"tissue\", \"Pharynx\", figsize=(6, 6))\n\nOf course, if a cluster is too spread out, the plot will not work as well, but it will still be useful to see the general location of the cluster.\n\nhighlighted_dimplot(planarian, \"Smed\", \"tissue\", \"Neural\", figsize=(6, 6))\n\nAnother case that might not work so well is if the shape of a cluster is not Gaussian. Still, it should help us spot the cluster, especially if the color contrasts enough.\n\nhighlighted_dimplot(\n    planarian, \"Smed\", \"tissue\", \"Muscle\", figsize=(6, 6), highlight=\"lightgreen\"\n)\n\n\nsource\n\n\n\n\ndef highlighted_heatmap(\n    to_plot, # A dataframe of pairwise similarities between cell types.\n    celltype_from, # Cell type of the query species to highlight. Must be in `to_plot.columns`.\n    celltype_to, # Cell type of the target species to highlight. Must be in `to_plot.index`.\n    figheight:int=20, # Height of the resulting plot in inches. Width will be calculated automatically (default:\n20).\n    save:NoneType=None, # Path to result figure; if None, the figure will be plotted but not saved (default: None).\n):\n\nPlot a heatmap of pairwise similarities between cell types, with a red box highlighting the query cell type.\n\nhysc = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"hysc_similarity_table.csv\",\n    index_col=0,\n)\n\n\nhighlighted_heatmap(\n    hysc, celltype_from=\"hy_i_SC\", celltype_to=\"sc_Neoblast: 0\", figheight=12\n)\n\n\nsource\n\n\n\n\ndef annotated_heatmap(\n    sm:SAMAP, # SAMAP object\n    similarity:DataFrame, # Similarity matrix. Contains query species clusters as columns and target species clusters as rows.\n    query_species:str, # Query species ID. Will be used in the title. Should prepend the similarity matrix column names.\n    target_species:str, # Target species ID. Will be used in the title. Should prepend the similarity matrix row names.\n    query_clustering:str, # Query species clustering. Must be present in `sm.sams[query_species].adata.obs`.\n    target_clustering:str, # Target species clustering. Must be present in `sm.sams[target_species].adata.obs`.\n    query_coarse:Optional=None,\n    target_coarse:Optional=None, # Query species coarse clustering. Must be present in `sm.sams[query_species].adata.obs`. If None, will be set to `query_clustering` (default: None).\n    interactive:bool=False, # If True, will return a plotly figure. Otherwise, will return a matplotlib figure (default: False).\n    figsize:Optional=None,\n    save:Optional=None, # Figure size. If None, will be guessed from the size of the similarity matrix (default: None).\n    kwargs:Any\n)-&gt;Optional: # If not None, will save the figure to the specified path (default: None).\nAdditional arguments to pass to `seaborn.heatmap` (matplotlib) or `plotly.graph_objects.Figure` (plotly). Among them: dpi (int), which is only used if `interactive=True` to set the figure size in pixels.\n\nPlot the similarity matrix as an annotated heatmap.\nRead the requisite files: the SAMap object and the pairwise cluster similarity matrix.\n\nfile = open(os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl.pkl\", \"rb\")\nsm = pickle.load(file)\n\nhypl = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl_similarity_table.csv\",\n    index_col=0,\n)\n\nFirst improve the coarse level assignments for the data we have here:\n\nsm.sams[\"hy\"].adata.obs[\"coarse\"] = (\n    sm.sams[\"hy\"].adata.obs[\"Cluster\"].str.split(\"_\").str[0]\n)\nsm.sams[\"pl\"].adata.obs[\"coarse\"] = (\n    sm.sams[\"pl\"].adata.obs[\"tissue_smedwi\"].str.split(\"_\").str[0]\n)\n\n\nannotated_heatmap(\n    sm,\n    hypl,\n    \"hy\",\n    \"pl\",\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_coarse=\"coarse\",\n    target_coarse=\"coarse\",\n    interactive=False,\n    save=\"hypl.pdf\",\n)\n\nThis sort of plot does a much better job of showing the relationships between clusters than the Sankey diagram. Clear patches of similarity emerge that would be otherwise invisible. This is a result of the hierarchical relationship between cell types (see Arendt/Musser/Wagner in 2016 and 2019). By combining maps like this with the per-species cell type family trees we can start to get a better idea of how cell types may have evolved over time.\n\nassert os.path.exists(\"hypl.pdf\")\n\nWe can make the same plot in interactive form. Unfortunately, the interactive version is a bit more finicky with color usage, so for now I’ll let plotly choose the colors, but any plotly wizards out there are welcome to improve this. Right now hovering over a point will show the cluster names and SAMap score; hovering over the colored bars at the margins should show the coarse cluster.\n\nplotly_overview = annotated_heatmap(\n    sm,\n    hypl,\n    \"hy\",\n    \"pl\",\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_coarse=\"coarse\",\n    target_coarse=\"coarse\",\n    figsize=(10, 10),\n    interactive=True,\n    dpi=100,\n    save=\"hypl\",\n)\n\n\nassert os.path.exists(\"hypl.json\")\nassert os.path.exists(\"hypl.html\")\n\nYou can visualize the plot in a notebook with:\n# not run\nplotly_overview.show()",
    "crumbs": [
      "plot"
    ]
  },
  {
    "objectID": "plot.html#pairwise-comparisons",
    "href": "plot.html#pairwise-comparisons",
    "title": "plot",
    "section": "Pairwise comparisons",
    "text": "Pairwise comparisons\nWhen comparing two clusters, it is most informative to have a look at the genes they are expressing. If the clusters are in the same species we can use a simple dotplot that combines the two clusters’ marker genes; things are not so simple when comparing between species. By plotting two dotplots side by side, and connecting homologous genes across the dotplots, we can get a better sense of how the clusters are connected.\nA lot of the heavy lifting for this idea was already done by the scanpy team, who write excellent, well-documented code. I’ve adapted their code to produce the paired dotplots, fiddled with it to make sure dot size and color are consistent across plots, and added the homology lines. The latter part is rather tricky, and I would be thankful to anyone who can improve it; currently it involves a lot of heuristics to translate the coordinates from one side of the plot to the other.\n\nsource\n\npaired_dotplot\n\ndef paired_dotplot(\n    query:AnnData, # query species AnnData object\n    target:AnnData, # target species AnnData object\n    connections:array, # array of connected genes. Each row has at least two columns containing the query species gene and corresponding target species gene, and optionally their connection strength. Genes are allowed to be repeated on both sides.\n    query_clustering:str, # `.obs` column in the query AnnData object containing the query species clustering.\n    target_clustering:str, # `.obs` column in the target AnnData object containing the target species clustering.\n    query_species:str, # query species name. Will only be used in the title, so does not have to conform with the query species ID in the similarity matrix/SAMap object.\n    target_species:str, # target species name. Will only be used in the title, so does not have to conform with the target species ID in the similarity matrix/SAMap object.\n    query_cluster:Optional=None,\n    target_cluster:Optional=None, # the cell type/cluster of the query species that is being compared (default: None).\n    pad:bool=True, # whether to pad the gene names with spaces to make them all of a similar length (default: True).\n    x_offset:float=1, # Number of inches to add to the horizontal size of the canvas (default: 1).\n    y_offset:float=0, # Number of inches to add to the vertical size of the canvas (default: 0).\n    grid_offset:float=30, # Grid segments to add between the two dotplots. Might be useful if the gene names are not legible/lines overlap (default: 30).\n    query_gene_names:Optional=None,\n    target_gene_names:Optional=None, # `.var` column that holds unique gene names for the query species (default: None).\n    output:str='./paired_dotplot.png', # path to save the plot to (default: \"./paired_dotplot.png\").\n    center:bool=True, # whether to center the dotplot (default: True).\n    title:Optional=None, # overall title of the plot (default: None).\n    title_font_size:float=16, # font size of the overall plot title (default: 16).\n    scale:bool=False, # whether to scale the expression values to be between 0 and 1 for each gene (default: False).\n    cmap:Colormap='magma_r', # colormap to use for the dotplot (default: \"viridis\").\n    layer:Optional=None, # layer : Union[str, None], optional The layer to use for the average expression calculation. If not specified, it will use the `.X` slot of the `AnnData` objects. It is vital to set this correctly to avoid calculating average expression on log1p-transformed data (default: None).\n)-&gt;None:\n\nRecall that scanpy dotplots need three inputs: the AnnData object, the names of genes to plot, and the name of the clustering. For paired dotplots we need this information for both sides of the plot.\nHowever, genes are input via the connections slot; an array where each row contains two genes and (optionally) the strength of their connection. The function will reorder the genes in order to plot the densely connected gene groups first, and will also color-code each group to make reading the plot easier.\nAdditionally, since plots like this may become busy very fast, the function also accepts the names of the two clusters to be compared; it will then highlight the cluster names in the plot.\nWe are going to prepare the inputs first:\n\nhydra = sm.sams[\"hy\"].adata  # the query dataset\nplanarian = sm.sams[\"pl\"].adata  # the target dataset\nplanarian.raw.var.index = \"pl_\" + planarian.raw.var.index\n\n# the .obs column that contains the cluster labels\nquery_clustering = \"Cluster\"\ntarget_clustering = \"cluster\"\n\n# the species IDs\nquery_species = \"hy\"\ntarget_species = \"pl\"\n\n# the cluster labels to highlight\ncluster_from = \"ecEp_SC2\"\ncluster_to = \"Epidermal: 2\"\n\nThe connections option is provided in this form deliberately, in order to allow the user to decide which genes to connect and how. This may cost a little extra effort for the most common cases, but it means that the function is more flexible.\nThe function currently supports three types of connections, corresponding to connection strength of [0, 1, 2], accordingly. It’s up to the user to assign meaning to the levels. The linestyles that correspond to these are\n\ndotted for 0 (linestyle = (0, (1, 5)))\ndashed for 1 (linestyle = (0, (5, 5)))\nsolid for 2\n\nIn the future I would like to let the user specify the linestyles, but for now this is what we have.\n\n\nClick here for some possible applications\n\n\nwhen comparing a dataset to itself, we could connect a gene to all its paralogs and visualize patterns of paralog substitution in cell type complement of an organism.\n\n\n\nhydra_genes = np.array(\n    [\"hy_t13309aep\", \"hy_t14973aep\", \"hy_t10876aep\", \"hy_t38670aep\", \"hy_t19278aep\"]\n)\nplan_genes = np.array(\n    [\n        \"pl_dd_Smed_v4_361_0_1\",\n        \"pl_dd_Smed_v4_361_0_1\",\n        \"pl_dd_Smed_v4_1215_0_1\",\n        \"pl_dd_Smed_v4_1131_0_1\",\n        \"pl_dd_Smed_v4_1971_0_1\",\n    ]\n)\north_scores = np.array([0, 0, 1, 2, 2])\n\n# connections without orthology scores\nconnections_plain = np.array([hydra_genes, plan_genes]).T\n\n# connections with orthology scores\nconnections_orth = np.array([hydra_genes, plan_genes, orth_scores], dtype=object).T\n\nLet’s have a look at what we feed into the function:\n\npd.DataFrame(connections_plain)\n\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections_plain,\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=cluster_from,\n    target_cluster=cluster_to,\n    pad=False,\n)\n\nGene expression can be very different between species, and plotting on the same scale can therefore be misleading. To address this, the function has a scale parameter that will normalize each row (gene) to a range of [0, 1]. This will make the plots more comparable, but it will also obscure the absolute expression levels. Use with caution.\nAnother thing to pay attention to: the scale function is not aware of log-transformed data, so if you applied log1p to your data it will calculate the an average-of-log instead of the log-of-average. This is a problem, and to avoid it please always use a layer that holds raw or normalised counts when using scale=True.\n\nhydra.X.data = np.exp(hydra.X.data) - 1\nhydra.layers[\"norm_counts\"] = hydra.X.copy()\nsc.pp.log1p(hydra)\n\nplanarian.X.data = np.exp(planarian.X.data) - 1\nplanarian.layers[\"norm_counts\"] = planarian.X.copy()\nsc.pp.log1p(planarian)\n\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections_plain,\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=cluster_from,\n    target_cluster=cluster_to,\n    pad=False,\n    scale=True,\n    cmap=\"RdYlBu_r\",\n    layer=\"norm_counts\",\n)\n\nSince we didn’t supply any weights for the connections, the function uses a weight of 0, and plots all connections we provided as dotted lines. Let’s try again, this time with weights:\n\n\n\nWARNING - Gene name padding:\n\nWe used pad=False here because we used the gene IDs instead of gene symbols. Gene symbols tend to have the same length, and so pad doesn’t help here. In fact pad=True will throw an issue here, indicating possibly sloppy code. Unfortunately fixing this is not a priority.\n\n\n\npd.DataFrame(connections_orth)\n\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections_orth,\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=cluster_from,\n    target_cluster=cluster_to,\n    pad=False,\n    scale=True,\n    cmap=\"RdYlBu_r\",\n    layer=\"norm_counts\",\n)\n\nWith weighting we can add an additional layer of information to the plot, such as orthology.\nThe next level would be to include the gene names, making this plot actually useful. For this to work reliably you need to have a column in the .var slot of your AnnData object that contains unique gene names. This is easily achieved by prepending the gene ID to the gene name/description.\nThe following code block is how I usually do this with EggNOG-mapper annotations; feel free to use whatever works for you.\n\n\nCode\nquery = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"eggnog/hydra.tsv\", sep=\"\\t\", engine=\"python\"\n)\n\nquery = query[[\"Unnamed: 0\", \"5\", \"eggNOG_OGs\", \"21\"]].copy()\nquery.columns = [\"gene_id\", \"gene_name\", \"eggNOG_OGs\", \"description\"]\nquery[\"gene_id\"] = \"hy_\" + query[\"gene_id\"].astype(str)\nquery.set_index(\"gene_id\", inplace=True)\nquery[\"name\"] = (\n    query.index.astype(str)\n    + \" | \"\n    + query[\"gene_name\"].fillna(\"\")\n    + \" | \"\n    + query[\"description\"].fillna(\"\")\n)\n\nhydra.var[\"name\"] = hydra.var.index\nhydra.var[\"name\"] = hydra.var[\"name\"].replace(query[\"name\"].to_dict())\n\nhy_t33417aep = \"hy_t33417aep | EPT1 | diacylglycerol cholinephosphotransferase activity\"\nassert hydra.var.loc[\"hy_t33417aep\"][\"name\"] == hy_t33417aep\n\n\nI have now created a column called name in the .var slot of the AnnData object. I can use this to plot the gene names instead of the gene IDs:\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections_orth,\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=cluster_from,\n    target_cluster=cluster_to,\n    query_gene_names=\"name\",\n    scale=True,\n    cmap=\"RdYlBu_r\",\n    layer=\"norm_counts\",\n)\n\nThe right side of the plot is left as an exercise to the reader :) Notice how the lines on the left side are not starting from the same spot. This is where the util.procrustes function tries to guess how to pad using space characters so that the plotted strings have approximately the same length and the lines don’t go over some longer gene names. It’s not perfect, but it’s better than nothing.\nFrom here on I will hide the lines of code that stay the same to make the notebook more readable. If you are trying to reproduce the plots, make sure you copy the code from the blocks above and just add the new lines.\nThe other options of the function should be self-explanatory, but I’ll go over them anyway:\n\nx_offset and y_offset control the canvas size beyond the size absolutely necessary for the plots to be rendered correctly. Increase x_offset to give the plots more x-axis space, and y_offset to give them more space on the vertical side. This is not an exact science, and you will find combinations that distort the plot to the point of making it unreadable.\n\n\npaired_dotplot(\n    query=hydra,  # |hide_line\n    target=planarian,  # |hide_line\n    connections=connections_orth,  # |hide_line\n    query_clustering=\"Cluster\",  # |hide_line\n    target_clustering=\"cluster\",  # |hide_line\n    query_species=\"hy\",  # |hide_line\n    target_species=\"pl\",  # |hide_line\n    query_cluster=cluster_from,  # |hide_line\n    target_cluster=cluster_to,  # |hide_line\n    query_gene_names=\"name\",  # |hide_line\n    x_offset=21,\n    y_offset=5,\n    scale=True,\n    cmap=\"RdYlBu_r\",\n)\n\nThe grid_offset parameter tries to control the space between the dotplots. Play with it if the lines connecting the genes are too short or too long. Try to stick to odd numbers, for some reason they work better. This gives you an additional lever for when increasing x_offset doesn’t work as intended.\nI will also stop including the scale=True option, but will keep showing different color maps.\n\npaired_dotplot(\n    query=hydra,  # |hide_line\n    target=planarian,  # |hide_line\n    connections=connections_orth,  # |hide_line\n    query_clustering=\"Cluster\",  # |hide_line\n    target_clustering=\"cluster\",  # |hide_line\n    query_species=\"hy\",  # |hide_line\n    target_species=\"pl\",  # |hide_line\n    query_cluster=cluster_from,  # |hide_line\n    target_cluster=cluster_to,  # |hide_line\n    query_gene_names=\"name\",  # |hide_line\n    grid_offset=131,\n    x_offset=21,\n    cmap=\"viridis\"\n)\n\n\npaired_dotplot(\n    query=hydra,  # |hide_line\n    target=planarian,  # |hide_line\n    connections=connections_orth,  # |hide_line\n    query_clustering=\"Cluster\",  # |hide_line\n    target_clustering=\"cluster\",  # |hide_line\n    query_species=\"hy\",  # |hide_line\n    target_species=\"pl\",  # |hide_line\n    query_cluster=cluster_from,  # |hide_line\n    target_cluster=cluster_to,  # |hide_line\n    query_gene_names=\"name\",  # |hide_line\n    grid_offset=13,\n    x_offset=21,\n    cmap=\"cividis\",\n)\n\nThe parameters title and title_font_size do what you expect them to do.\n\npaired_dotplot(\n    query=hydra,  # |hide_line\n    target=planarian,  # |hide_line\n    connections=connections_orth,  # |hide_line\n    query_clustering=\"Cluster\",  # |hide_line\n    target_clustering=\"cluster\",  # |hide_line\n    query_species=\"hy\",  # |hide_line\n    target_species=\"pl\",  # |hide_line\n    query_cluster=cluster_from,  # |hide_line\n    target_cluster=cluster_to,  # |hide_line\n    query_gene_names=\"name\",  # |hide_line\n    x_offset=31,\n    y_offset=2,\n    title=\"If my title is long and in big font size I need to use the function\\nparameters to make the plot bigger and push the plots to the sides\",\n    title_font_size=40,\n    grid_offset=71,\n    cmap=\"plasma\"\n)\n\nFinally, output controls where the plot is saved, and center=True will try to arrange the dotplots so that their centers on the y-axis are aligned. You probably want center=False if you need to print a title.",
    "crumbs": [
      "plot"
    ]
  },
  {
    "objectID": "plot.html#real-life-applications",
    "href": "plot.html#real-life-applications",
    "title": "plot",
    "section": "Real-life applications",
    "text": "Real-life applications\nWhen comparing cell types between species we are mostly interested in figuring out which cell types are homologous, and we want to find conserved gene expression patterns as evidence.\nOne way to get started with this is to look at the top marker genes of a cluster in one species and their homologs in the other animal.\nFor DEG detection I will use logistic regression, since I am interested in finding genes that are specifically expressed in my cluster of interest. I will take the \"enEp_foot\" cluster.\n\nsc.tl.rank_genes_groups(hydra, \"Cluster\", method=\"logreg\")\nsc.tl.rank_genes_groups(planarian, \"cluster\", method=\"logreg\")\n\nFor the sake of illustration let’s have a look at the top 30 genes:\n\ntop30 = hydra.uns[\"rank_genes_groups\"][\"names\"][\"ecEp_SC3\"][:30]\n\n\nsc.pl.dotplot(\n    hydra,\n    hydra.var[\"name\"].loc[top30],\n    gene_symbols=\"name\",\n    groupby=\"Cluster\",\n    cmap=\"magma_r\",\n    swap_axes=True,\n    use_raw=False,\n)\n\nThis might be too much information on the plot - many of the true marker genes are only expresed in the endodermal clusters anyway. I would like to collapse the other coarse clusters to make it more legible. I have a function for that:\n\nutil.collapse_unrelated_clusters(hydra, \"ecEp_SC3\", \"Cluster\", \"coarse\")\n\n\nsc.pl.dotplot(\n    hydra,\n    hydra.var[\"name\"].loc[top30],\n    gene_symbols=\"name\",\n    groupby=\"Cluster_collapsed\",\n    cmap=\"magma_r\",\n    swap_axes=True,\n    use_raw=False,\n)\n\nThis is much more legible. Use this at your own risk though, as it may hide important information.\nNow, let’s find the orthology information for these genes:\n\northology = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl_orthology.tsv\", sep=\"\\t\", index_col=0\n)\n\n\nkeep = np.intersect1d(\n    top30, orthology.index\n)  # for how many genes do we have orthology information?\navailable = orthology.loc[keep]  # subset to only include those\navailable_long = available.reset_index().melt(\n    \"gene_id\"\n)  # pivot the table to long format\navailable_long\n\nNow we can only keep the pairs with a score greater than zero:\n\nconnections = available_long[available_long[\"value\"] &gt; 0].to_numpy()\n\nWe will now also name the planarian genes so that the plot makes more sense:\n\n\nCode\ntarget = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"eggnog/planarian.tsv\", sep=\"\\t\", engine=\"python\"\n)\n\ntarget = target[[\"Unnamed: 0\", \"5\", \"eggNOG_OGs\", \"21\"]].copy()\ntarget.columns = [\"gene_id\", \"gene_name\", \"eggNOG_OGs\", \"description\"]\ntarget[\"gene_id\"] = \"pl_\" + target[\"gene_id\"].astype(str)\ntarget.set_index(\"gene_id\", inplace=True)\ntarget[\"name\"] = (\n    target.index.astype(str)\n    + \" | \"\n    + target[\"gene_name\"].fillna(\"\")\n    + \" | \"\n    + target[\"description\"].fillna(\"\")\n)\n\nplanarian.var[\"name\"] = planarian.var.index\nplanarian.var[\"name\"] = planarian.var[\"name\"].replace(target[\"name\"].to_dict())\n\n\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections,\n    query_clustering=\"Cluster_collapsed\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=\"ecEp_SC3\",\n    target_cluster=\"Epidermal: 2\",\n    query_gene_names=\"name\",\n    target_gene_names=\"name\",\n    x_offset=15,\n)\n\nThis approach will be sensitive but not very specific, as we will be plotting entire gene families on the target side. A more specific approach would be to look for genes that are markers on both sides and also homologous:\n\nhydra_top100 = hydra.uns[\"rank_genes_groups\"][\"names\"][\"ecEp_SC3\"][:100]\nplanarian_top100 = planarian.uns[\"rank_genes_groups\"][\"names\"][\"Epidermal: 2\"][:100]\n\n\nconnections = genes.get_orthologs_overlap(\n    hydra_top100, planarian_top100, hydra, planarian, orthology\n)\n\n\nconnections\n\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections,\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=\"ecEp_SC3\",\n    target_cluster=\"Epidermal: 2\",\n    query_gene_names=\"name\",\n    target_gene_names=\"name\",\n    pad=False,\n    x_offset=-5,\n)\n\nI clearly chose the wrong example here, but I hope you can see the idea behind the method, and how that could be useful when analysing your own data. Hopefully by comparing two species that are somewhat closer related than Hydra and Schmidtea.\nOr, since the methods I describe here are so flexible, you could use them to manually compile lists of marker genes and visualize those, to much greater effect than this half-baked attempt at finding needles in a haystack. You probably know your favorite species much better than I know Hydra and Schmidtea, after all!\nOr, and hear me out here, cnidarians might have a fundamentally different way of building their cell types compared to other metazoans, and so SAMap can’t find bonafide homologs. If we do all the pairwise comparisons and can’t find compelling evidence for homology, we can start to think about alternatives.\n\n\n\nDISCLAIMER\n\nYes, I know that cnidarians and the rest of the metazoans had a common origin and that there is compelling evidence that many of their cell types are probably, in fact, homologous. I also know your in-situ data probably shows stuff that slightly disagrees with the single-cell data. I am just using hyperbole to make a point. Please don’t sue me.",
    "crumbs": [
      "plot"
    ]
  }
]