[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ComAnDOS",
    "section": "",
    "text": "A draft is under preparation at comandos-paper.\n   \n\n\n\nAs a long-time user of SAMap and a connoisseur of cross-species comparisons, I was always frustrated by the lack of useful visualization downstream of SAMap results. We don’t need fancy software to figure out that ciliated cells are similar to ciliated cells, and muscle to muscle, but what about those pesky “unknown_sensory_2” and “ciliated?_2” clusters? ComAnDOS is a collection of plotting functions and assorted utilities that I hacked together to help myself and collaborators make sense of SAMap results. It is conceived as a SAMap add-on, but it doesn’t require it per se. It mostly works with two “primitives”: AnnData, and Pandas DataFrames, so it should be relatively easy to adapt to your use case.\nIt currently includes:\n\nfancy heatmaps (replace Sankey plots, circle plots)\npaired dotplots (directly compare cross-species expression!)\nassorted utility functions",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "index.html#publications",
    "href": "index.html#publications",
    "title": "ComAnDOS",
    "section": "",
    "text": "A draft is under preparation at comandos-paper.\n   \n\n\n\nAs a long-time user of SAMap and a connoisseur of cross-species comparisons, I was always frustrated by the lack of useful visualization downstream of SAMap results. We don’t need fancy software to figure out that ciliated cells are similar to ciliated cells, and muscle to muscle, but what about those pesky “unknown_sensory_2” and “ciliated?_2” clusters? ComAnDOS is a collection of plotting functions and assorted utilities that I hacked together to help myself and collaborators make sense of SAMap results. It is conceived as a SAMap add-on, but it doesn’t require it per se. It mostly works with two “primitives”: AnnData, and Pandas DataFrames, so it should be relatively easy to adapt to your use case.\nIt currently includes:\n\nfancy heatmaps (replace Sankey plots, circle plots)\npaired dotplots (directly compare cross-species expression!)\nassorted utility functions",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "index.html#background-and-motivation",
    "href": "index.html#background-and-motivation",
    "title": "ComAnDOS",
    "section": "Background and motivation",
    "text": "Background and motivation\n\n\nclick to expand\n\nSingle-cell RNA-seq (scRNA-seq) is a powerful tool to study the transcriptome of individual cells. As the technology matured, it became possible to use it on non-model organisms, facilitating cell type comparison across species. Early methods for this task subsetted gene expression matrices to one-to-one orthologous genes, assuming that sequence conservation also implies conservation of location, magnitude, and timing of gene expression. Not only is this assumption not true, but it also requires us to discard a large amount of data.\nSAMap was the first method to try and include many-to-one orthology relations. In alternating steps, it optimises a cell graph and a gene graph, using the former to inform the latter and vice versa. The result is a converged low-dimensional embedding that contains the cells of both species, allowing for direct comparison.\nSAMap comes with a small number of visualization tools, but, as I had to find out myself, they are not sufficient for in-depth analysis. In particular:\n\nSankey diagrams, SAMap’s default visualization for cluster-cluster relationships, obscure the fact that cell types are hierarchically organized. They also make it harder to quantify just how similar two cell types are according to SAMap.\nTarashansky et al. used network diagrams to demonstrate highly connected cell type families. I found that these diagrams are not very informative, as they are hard to read and do not scale well to large datasets.\nIn the publication, heatmaps are used once, but not to their full extent.\nOverlapping dimplots with corresponding violin plots are used to demonstrate co-expression across species. This is a good idea, but results in overloaded plots.\nThe authors use dotplots to show gene expression across species, color-coding the species. This loses one of the dotplots’ dimensions, where color usually encodes expression level, and forces the use of an additional axis to show expression magnitude. Furthermore, the relationships between the plotted genes in the different species are hard to visualize and need to be described in text.\n\nThese visualisations have two additional shortcomings: First, they are not easily reproducible, as they are not part of SAMap but rather custom solutions for very specific use cases. Second, they are extremely specific in what they show, and thus not useful for exploratory data analysis.",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "ComAnDOS",
    "section": "Documentation",
    "text": "Documentation\nThis package was developed using nbdev, which means the source code was generated from Jupyter notebooks using the literate programming paradigm. You can see the exported function signatures and assorted explanations online. I am currently working on tutorials for the most important use cases.\nFor questions or requests please open an issue on GitHub. I will be communicating updates, if any, on Twitter.\nExample data is available on Zenodo.",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "ComAnDOS",
    "section": "Install",
    "text": "Install\nIt is good practice to set up a virtual environment for your Python projects. I recommend conda, or mamba if you want faster package installation.\nconda create -n comandos python=3.9\nconda activate comandos\n\nGitHub\nFirst install dependencies:\npip install scanpy jupyterlab\nAfter installing dependencies, clone the latest version from GitHub and install it:\ncd /directory/of/choice\ngit clone https://github.com/galicae/comandos.git\ncd comandos\npip install -e .\n\n\nPyPi\npip install comandos",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "ComAnDOS",
    "section": "Getting started",
    "text": "Getting started\n&lt;list example notebooks here&gt;",
    "crumbs": [
      "ComAnDOS"
    ]
  },
  {
    "objectID": "genes.html",
    "href": "genes.html",
    "title": "genes",
    "section": "",
    "text": "SAMap is built on pairwise gene similarity. For cross-species comparisons it is often very interesting to know the level of conservation of two genes - mostly, whether they are orthologs or paralogs. I will provide functions to annotate genes with orthology information from EggNOG-mapper, but you can also use your own orthology annotation, provided it returns the same thing: a \\(G_1\n\\times G_2\\) table where \\(G_1\\) and \\(G_2\\) are the genes in the two species you are comparing, and each cell \\((g_1, g_2)\\) contains the orthology relationship between \\(g_1\\) and \\(g_2\\): 2, if they are orthologs, 1 if they are paralogs/in the same gene family, 0 if they are unrelated.\nThis is an extremely inefficient way of saving this matrix, and it would be relatively easy to code this as a sparse matrix, but I don’t think it’s worth the effort. The matrices are not too large (especially after the gene filtering that is so common to scRNA-seq analysis), and even home computers commonly pack 16GB of RAM these days. Unless you are working with Frankenstein’d genomes with tens of thousands of “genes” you will be fine.\nFirst we will need to read in the EggNOG-mapper result file.\n\n\n\nWARNING - EggNOG format:\n\nDepending on the version of EggNOG you may get a slightly different file; you will need to filter it down to the two columns we need: the query gene ID and the orthogroup assignments. These are a comma-separated string in the format orthogroup_ID@taxonomic_level. The taxonomic level will determine whether genes are orthologs or paralogs, so choose wisely. I am using \"Eukaryota\" and \"Bilateria\" as defaults, but it may well be that your version of EggNOG is using NCBI taxonomic IDs instead of verbose names. Please check before applying!\n\n\n\n\n\nWARNING - Index matching:\n\nFor the entries of the EggNOG table to match to the gene names in the SAMap object we need to make sure the index of query matches to the index of sm.sams[query_species].adata.var. If you created the files in the scheme that I am following, this means that you prepended the species ID to the gene IDs; we would need to do the same here.\n\n\n\nquery = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"eggnog/hydra.tsv\",\n    sep=\"\\t\",\n    engine=\"python\",\n)\nquery = query[\n    [\"Unnamed: 0\", \"eggNOG_OGs\"]\n].copy()  # I am only keeping the columns I need\nquery.columns = [\"gene_id\", \"eggNOG_OGs\"]  # rename so that it is easier to work with\nquery[\"gene_id\"] = \"hy_\" + query[\"gene_id\"].astype(str)\n\n\nquery\n\n\n\n\n\n\n\n\n\ngene_id\neggNOG_OGs\n\n\n\n\n0\nhy_t33417aep\n38ERC@33154,3NUD8@4751,3QR2W@4890,3RR2D@4891,C...\n\n\n1\nhy_t33418aep\n2CN11@1,2QT83@2759,38D3X@33154,3BDRF@33208,3CX...\n\n\n2\nhy_t37645aep\n38CHP@33154,3B9GY@33208,COG2124@1,KOG0157@2759\n\n\n3\nhy_t31628aep\nKOG1075@1,KOG1075@2759,KOG4475@1,KOG4475@2759\n\n\n4\nhy_t33265aep\n3QB9P@4776,COG3145@1,KOG2731@2759\n\n\n...\n...\n...\n\n\n18265\nhy_t24932aep\n3A1BV@33154,3BQ1H@33208,KOG1121@1,KOG1121@2759\n\n\n18266\nhy_t24930aep\n2E9XV@1,2SG7Z@2759\n\n\n18267\nhy_t24940aep\nKOG0118@1,KOG0118@2759\n\n\n18268\nhy_t29557aep\n2CZA0@1,2S9AH@2759,3ABW2@33154,3BVK1@33208\n\n\n18269\nhy_t29564aep\nCOG2340@1,KOG3017@2759\n\n\n\n\n18270 rows × 2 columns\n\n\n\n\nNow we will filter the EggNOG_OGs column and only keep the two levels that we’re interested in. Since we are comparing Hydra to a planarian we should be using the Metazoa level for orthologs. We can see from the table visualization that this table uses NCBI tax IDs, so we should look up the tax ID for Metazoa (33208). Similarly, if we would like to use the Eukaryota level for paralogs, we need its tax ID (2759).\nWe also need a function that will filter the orthology table to only keep the OGs that belong to the specified levels:\n\nsource\n\nfilter_OGs\n\n filter_OGs (x:Union[list,str], paralog:str='Eukaryota',\n             ortholog:str='Bilateria')\n\nFind the EggNOG OGs at the the paralog and ortholog level.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx\ntyping.Union[list, str]\n\n\n\n\nparalog\nstr\nEukaryota\nthe level of the paralog OG\n\n\northolog\nstr\nBilateria\nthe level of the ortholog OG\n\n\nReturns\nlist\n\nthe paralog OG and ortholog OG\n\n\n\nThis function will filter one EggNOG string (or list) to the specified levels.\n\nquery[\"eggNOG_OGs\"].loc[0]\n\n'38ERC@33154,3NUD8@4751,3QR2W@4890,3RR2D@4891,COG5050@1,KOG2877@2759'\n\n\n\ninput_str = query[\"eggNOG_OGs\"].loc[0]\nparalog_str, ortholog_str = filter_OGs(input_str, paralog=\"2759\", ortholog=\"33208\")\nassert paralog_str == \"KOG2877@2759\"\nassert ortholog_str == \"\"\n\n\ninput_list = query[\"eggNOG_OGs\"].loc[0].split(\",\")\nparalog_list, ortholog_list = filter_OGs(input_list, paralog=\"2759\", ortholog=\"33208\")\nassert paralog_list == \"KOG2877@2759\"\nassert ortholog_list == \"\"\n\n\nsource\n\n\nassign_homology\n\n assign_homology (species_OGs, paralog:str='Eukaryota',\n                  ortholog:str='Bilateria')\n\nGet the taxonomy of the genes.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nspecies_OGs\n\n\nthe dataframe with the gene_id and the EggNOG OGs\n\n\nparalog\nstr\nEukaryota\nthe level of the paralog OG\n\n\northolog\nstr\nBilateria\nthe level of the ortholog OG)\n\n\nReturns\nDataFrame\n\nthe dataframe with the gene_id, paralog OG and ortholog OG\n\n\n\n\nhydra_genes = assign_homology(query, paralog=\"2759\", ortholog=\"33208\")\n\n\nhydra_genes\n\n\n\n\n\n\n\n\n\northolog\nparalog\n\n\ngene_id\n\n\n\n\n\n\nhy_t10003aep\n3BCY5@33208\nKOG3599@2759\n\n\nhy_t10008aep\nNone\nKOG1075@2759\n\n\nhy_t10009aep\n3BA48@33208\nKOG1545@2759\n\n\nhy_t10011aep\n3BFGW@33208\nKOG1136@2759\n\n\nhy_t10012aep\n3BKRE@33208\nKOG2527@2759\n\n\n...\n...\n...\n\n\nhy_t998aep\n3C06S@33208\n2S418@2759\n\n\nhy_t9990aep\nNone\nKOG0490@2759\n\n\nhy_t9992aep\n3B9JS@33208\nKOG0573@2759\n\n\nhy_t999aep\nNone\n2RZ1Z@2759\n\n\nhy_t99aep\n3BH2P@33208\nKOG2861@2759\n\n\n\n\n18270 rows × 2 columns\n\n\n\n\n\nassert hydra_genes.loc[\"hy_t10003aep\"][\"paralog\"] == \"KOG3599@2759\"\nassert hydra_genes.loc[\"hy_t10003aep\"][\"ortholog\"] == \"3BCY5@33208\"\n\nRepeat for the target species (planarian):\n\ntarget = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"eggnog/planarian.tsv\",\n    sep=\"\\t\",\n    engine=\"python\",\n)\ntarget = target[\n    [\"Unnamed: 0\", \"eggNOG_OGs\"]\n].copy()  # I am only keeping the columns I need\ntarget.columns = [\"gene_id\", \"eggNOG_OGs\"]  # rename so that it is easier to work with\ntarget[\"gene_id\"] = \"pl_\" + target[\"gene_id\"].astype(str)\n\nplanarian_genes = assign_homology(target, paralog=\"2759\", ortholog=\"33208\")\n\nGiven the orthology assignments (orthogroup membership), it is now very easy to calculate which cross-species genes are orthologs or paralogs; we just need to compare the columns of the orthology tables and keep score.\n\nsource\n\n\ncalculate_orthology_score\n\n calculate_orthology_score (query:pandas.core.frame.DataFrame,\n                            target:pandas.core.frame.DataFrame)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nquery\nDataFrame\nthe dataframe with the gene_id, paralog OG and ortholog OG for the query species\n\n\ntarget\nDataFrame\n\n\n\nReturns\nDataFrame\n\n\n\n\n\northology_score = calculate_orthology_score(hydra_genes, planarian_genes)\n\n\ngene1 = \"pl_dd_Smed_v4_10002_0_1\"\ngene2 = \"hy_t25984aep\"\n\nannot1 = target.set_index(\"gene_id\").loc[gene1]\nannot2 = query.set_index(\"gene_id\").loc[gene2]\n\nprint(annot1[\"eggNOG_OGs\"])\nprint(annot2[\"eggNOG_OGs\"])\n\n38GXK@33154,3BHNW@33208,3CZKV@33213,47ZE5@7711,48WIG@7742,4CF02@8459,KOG2397@1,KOG2397@2759\n38GXK@33154,3BHNW@33208,KOG2397@1,KOG2397@2759\n\n\nThese genes are orthologs, we should therefore expect them to have an orthology score of 2:\n\nassert orthology_score[gene1].loc[gene2] == 2\n\nWe can save the orthology table to disk for later use:\n# not run\northology_score.to_csv(\"path/to/hypl_orthology.tsv\", sep=\"\\t\")\n\nsource\n\n\nget_orthologs_overlap\n\n get_orthologs_overlap (genes1, genes2, query, target, orthology)\n\nReturns a DataFrame of homologous gene pairs between two sets of genes based on their presence in an orthology table.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ngenes1\nnumpy.ndarray\nA series of gene names.\n\n\ngenes2\nnumpy.ndarray\nA series of gene names.\n\n\nquery\nanndata.AnnData\nAn AnnData object containing the query genes as indices of the .var slot.\n\n\ntarget\nanndata.AnnData\nAn AnnData object containing the target genes as indices of the .var slot.\n\n\northology\npandas.core.frame.DataFrame\nA DataFrame containing the orthology information.\n\n\nReturns\npandas.core.frame.DataFrame\nA DataFrame of homologous gene pairs and their degree of conservation. The array hasthree columns: ‘query’, ‘target’, and ‘degree’, where ‘query’ and ‘target’ are the genenames, and ‘degree’ is the degree of conservation, which can be either 1 or 2.\n\n\n\n\nsource\n\n\nget_orthologs\n\n get_orthologs (genes:numpy.ndarray,\n                orthology:pandas.core.frame.DataFrame,\n                target:anndata._core.anndata.AnnData, celltype_to:str)\n\nGet orthologous and paralogous gene connections based on the given genes and orthology information.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ngenes\nndarray\nArray of gene names.\n\n\northology\nDataFrame\nData frame representing the orthology information. The index should contain the query genes,the columns should overlap with the index of target.var, and the values should be 1 forparalogs and 2 for orthologs.\n\n\ntarget\nAnnData\nTarget annotation data.\n\n\ncelltype_to\nstr\nThe target cell type. Must be a key in target.uns[\"rank_genes_groups\"][\"names\"].\n\n\nReturns\nndarray\nArray of connections between genes, including orthologous and paralogous connections.Columns are (query, target, degree), where degree is 1 for paralogs and 2 for orthologs.",
    "crumbs": [
      "genes"
    ]
  },
  {
    "objectID": "dotplot_util.html",
    "href": "dotplot_util.html",
    "title": "dotplot_util",
    "section": "",
    "text": "This module contains a collection of utility functions for the pairwise dotplots, as well as some more general functions that are used in the dotplot generation process. I wrote documentation for the functions here, but I didn’t write tests for them. I’m not sure this page is very valuable to end users.\n\nsource\n\nhighlight_cluster\n\n highlight_cluster (clusters:numpy.ndarray, cluster:Optional[str]=None,\n                    bg:Union[str,tuple]='black',\n                    hl:Union[str,tuple]='red')\n\nHighlight a cluster in a list of clusters by setting the color of the cluster to hl and the color of the rest to bg.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nclusters\nndarray\n\nThe array of cluster names.\n\n\ncluster\ntyping.Optional[str]\nNone\nThe cluster to highlight (default: None).\n\n\nbg\ntyping.Union[str, tuple]\nblack\nThe background color. Accepts all matplotlib-compatible color formats (default: “black”).\n\n\nhl\ntyping.Union[str, tuple]\nred\nThe highlight color. Accepts all matplotlib-compatible color formats (default: “red”).\n\n\nReturns\nndarray\n\nThe array of colors, with the same length as clusters.\n\n\n\n\nsource\n\n\nunique_genes\n\n unique_genes (connections:numpy.ndarray)\n\nExtract the unique gene names from an array of connections.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nconnections\nndarray\nThe array of connections. Columns should be (query_genes, target_genes, connection_strength). The last column is optional.\n\n\nReturns\nndarray\nThe array of unique genes.\n\n\n\n\nsource\n\n\nmap_to_colormap\n\n map_to_colormap (x:numpy.ndarray,\n                  cmap:Union[str,matplotlib.colors.Colormap]='magma_r',\n                  vmin:float=0, vmax:Optional[float]=None)\n\nMap an array of values to a color palette.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx\nndarray\n\nThe array to map.\n\n\ncmap\ntyping.Union[str, matplotlib.colors.Colormap]\nmagma_r\nThe color map to use. Should be a matplotlib colormap object or a string with the name of a matplotlib colormap (default: “magma_r”).\n\n\nvmin\nfloat\n0\nThe value to obtain the minimum color in the colormap. Should be &lt;= np.min(x) to avoid truncation (default: 0).\n\n\nvmax\ntyping.Optional[float]\nNone\nThe value to obtain the maximum color in the colormap. Should be &gt;= np.max(x), and will use np.max(x) if set to None (default: None).\n\n\nReturns\nndarray\n\nArray of RGBA values with a shape of x.shape + (4, ).\n\n\n\n\nsource\n\n\nmap_array_to_color\n\n map_array_to_color (x:numpy.ndarray, palette:matplotlib.colors.Colormap,\n                     xmax:Optional[float]=None)\n\nMap an array of values to a color palette.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx\nndarray\n\nThe array to map.\n\n\npalette\nColormap\n\nThe color map to use. Should be a matplotlib colormap object.\n\n\nxmax\ntyping.Optional[float]\nNone\nThe maximum value to use for normalization. Should be &gt;= np.max(x), and will use np.max(x) if set to None (default: None).\n\n\nReturns\nndarray\n\nArray of RGBA values with a shape of x.shape + (4, ).\n\n\n\n\nsource\n\n\nadd_homology_context\n\n add_homology_context (connections:numpy.ndarray,\n                       orthology:pandas.core.frame.DataFrame)\n\nAdd homology context to the given connections based on the orthology information.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nconnections\nndarray\nThe connections between genes. The columns should be (query_gene, target_gene).\n\n\northology\nDataFrame\nThe orthology information as a DataFrame.\n\n\nReturns\nndarray\nThe connections array with homology context added. The columns will be (query_gene,target_gene, connection_strength), and the values in connection_strength will depend on thecontent of the orthology DataFrame.\n\n\n\n\nsource\n\n\nplot_dotplot\n\n plot_dotplot (query_avg_expr:numpy.ndarray,\n               target_avg_expr:numpy.ndarray,\n               query_perc_expr:numpy.ndarray,\n               target_perc_expr:numpy.ndarray, query_genes:List[str],\n               target_genes:List[str], connections:numpy.ndarray,\n               query_cluster_colors:Dict[str,str],\n               target_cluster_colors:Dict[str,str],\n               query_gene_colors:Dict[str,str],\n               target_gene_colors:Dict[str,str], query_species:str,\n               target_species:str, x_offset:float=1, y_offset:float=0,\n               grid_offset:int=30, query_clustering:str='leiden',\n               target_clustering:str='leiden',\n               output:str='./paired_dotplot.png',\n               title:Optional[str]=None, title_font_size:int=16,\n               center:bool=True,\n               cmap:matplotlib.colors.Colormap='magma_r')\n\nPlot the paired dotplot based on the given data.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nquery_avg_expr\nndarray\n\nArray representing the average expression values of query genes.\n\n\ntarget_avg_expr\nndarray\n\nArray representing the average expression values of target genes.\n\n\nquery_perc_expr\nndarray\n\nArray representing the percentage expression values of query genes.\n\n\ntarget_perc_expr\nndarray\n\nArray representing the percentage expression values of target genes.\n\n\nquery_genes\ntyping.List[str]\n\nList of query gene names.\n\n\ntarget_genes\ntyping.List[str]\n\nList of target gene names.\n\n\nconnections\nndarray\n\nAn array where each row contains two genes and (optionally) the strength of theirconnection.\n\n\nquery_cluster_colors\ntyping.Dict[str, str]\n\nDictionary mapping query cluster names to their colors.\n\n\ntarget_cluster_colors\ntyping.Dict[str, str]\n\nDictionary mapping target cluster names to their colors.\n\n\nquery_gene_colors\ntyping.Dict[str, str]\n\nDictionary mapping query gene names to their colors.\n\n\ntarget_gene_colors\ntyping.Dict[str, str]\n\nDictionary mapping target gene names to their colors.\n\n\nquery_species\nstr\n\nSpecies name of the query genes.\n\n\ntarget_species\nstr\n\nSpecies name of the target genes.\n\n\nx_offset\nfloat\n1\nOffset for the x-axis (default: 1).\n\n\ny_offset\nfloat\n0\nOffset for the y-axis (default: 0).\n\n\ngrid_offset\nint\n30\nOffset for the grid spacing (default: 30).\n\n\nquery_clustering\nstr\nleiden\nClustering method for the query genes (default: “leiden”).\n\n\ntarget_clustering\nstr\nleiden\nClustering method for the target genes (default: “leiden”).\n\n\noutput\nstr\n./paired_dotplot.png\nOutput file path for the plot (default: “./paired_dotplot.png”).\n\n\ntitle\ntyping.Optional[str]\nNone\nTitle of the plot (default: None).\n\n\ntitle_font_size\nint\n16\nFont size of the plot title (default: 16).\n\n\ncenter\nbool\nTrue\nWhether to center the dotplots when the number of genes exceeds the maximum (default: True).\n\n\ncmap\nColormap\nmagma_r\n\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\nadd_connections\n\n add_connections (fig:matplotlib.figure.Figure, connections:numpy.ndarray,\n                  query_gene_names:List[str],\n                  query_gene_colors:Dict[str,str], label_offset:float)\n\nAdd connections between genes to the given paired dotplot figure.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfig\nFigure\nThe paired dotplot figure to which the connections will be added.\n\n\nconnections\nndarray\nAn array where each row contains two genes and (optionally) the strength of theirconnection.\n\n\nquery_gene_names\ntyping.List[str]\nThe list of query gene names.\n\n\nquery_gene_colors\ntyping.Dict[str, str]\nThe dictionary mapping query gene names to their colors.\n\n\nlabel_offset\nfloat\nThe offset for label positioning.\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nmake_dotplot\n\n make_dotplot (ax:matplotlib.axes._axes.Axes, avg:numpy.ndarray,\n               perc:numpy.ndarray, gene_names:List[str], species:str,\n               clustering:str, clust_color:List[str],\n               gene_color:List[str], side:str='left',\n               cmap:matplotlib.colors.Colormap='magma_r')\n\nMake a dotplot on the given Axes object based on the average and percentage expression values.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nax\nAxes\n\nThe Axes object on which to create the dotplot.\n\n\navg\nndarray\n\nThe average expression values.\n\n\nperc\nndarray\n\nThe percentage expression values.\n\n\ngene_names\ntyping.List[str]\n\nThe list of gene names.\n\n\nspecies\nstr\n\nThe species name.\n\n\nclustering\nstr\n\nThe clustering information.\n\n\nclust_color\ntyping.List[str]\n\nThe list of colors for clusters.\n\n\ngene_color\ntyping.List[str]\n\nThe list of colors for genes.\n\n\nside\nstr\nleft\nThe side to place the y-axis labels, either “left” or “right” (default: “left”).\n\n\ncmap\nColormap\nmagma_r\n\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\nplot_colorbar_legend\n\n plot_colorbar_legend (cbar_legend:matplotlib.axes._axes.Axes,\n                       query_avg_expr:numpy.ndarray,\n                       target_avg_expr:numpy.ndarray,\n                       cmap:matplotlib.colors.Colormap='magma_r')\n\nPlot the colorbar legend based on the average expression values of query and target genes.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncbar_legend\nAxes\n\nThe Axes object representing the colorbar legend.\n\n\nquery_avg_expr\nndarray\n\nArray representing the average expression values of query genes.\n\n\ntarget_avg_expr\nndarray\n\nArray representing the average expression values of target genes.\n\n\ncmap\nColormap\nmagma_r\nThe Colormap instance or registered colormap name used to map scalar data to colors(default: “magma_r”).\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\nplot_dot_legend\n\n plot_dot_legend (dot_legend, size_exponent=1.5, dot_size=200)\n\nCreate the dotplot legend, explaining dot size.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndot_legend\nmatplotlib axis\n\nThe subplot of the grid that contains the dotplot legend.\n\n\nsize_exponent\nfloat\n1.5\nThe exponent to raise the fraction of cells in a group to, to get the dot size. The defaultis 1.5.\n\n\ndot_size\nint\n200\nThe size of the largest dot. The default is 200.\n\n\n\n\nsource\n\n\nget_dot_color\n\n get_dot_color (query:anndata._core.anndata.AnnData,\n                target:anndata._core.anndata.AnnData,\n                query_clustering:str, target_clustering:str,\n                query_genes:Optional[numpy.ndarray]=None,\n                target_genes:Optional[numpy.ndarray]=None,\n                query_gene_names:Optional[numpy.ndarray]=None,\n                target_gene_names:Optional[numpy.ndarray]=None,\n                layer:Optional[str]=None)\n\nCalculate average expression in each cluster and translate that to dot color for the dotplot. Note that this function does not know what you did with the matrix before; if you have log-transformed the data it will calculate an average of logs, not the log of the exp-transformed average.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nquery\nAnnData\n\nThe query dataset.\n\n\ntarget\nAnnData\n\nThe target dataset.\n\n\nquery_clustering\nstr\n\nThe .obs column name to use for the query dataset.\n\n\ntarget_clustering\nstr\n\nThe .obs column name to use for the target dataset.\n\n\nquery_genes\ntyping.Optional[numpy.ndarray]\nNone\nArray of query genes to subset the data, if any. If None, use all genes (default: None).\n\n\ntarget_genes\ntyping.Optional[numpy.ndarray]\nNone\nArray of target genes to subset the data, if any. If None, use all genes (default: None).\n\n\nquery_gene_names\ntyping.Optional[numpy.ndarray]\nNone\nArray of query gene names (default: None).\n\n\ntarget_gene_names\ntyping.Optional[numpy.ndarray]\nNone\nArray of target gene names (default: None).\n\n\nlayer\ntyping.Optional[str]\nNone\nThe layer to use for the average expression calculation. If not specified, it will use the.X slot of the AnnData objects. It is vital to set this correctly to avoid calculatingaverage expression on log1p-transformed data (default: None).\n\n\nReturns\ntyping.Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]\n\nA tuple containing the dot color values for query and target datasets, respectively.\n\n\n\n\nsource\n\n\nget_dot_size\n\n get_dot_size (query:pandas.core.frame.DataFrame,\n               target:pandas.core.frame.DataFrame, query_clustering:str,\n               target_clustering:str,\n               query_genes:Optional[numpy.ndarray]=None,\n               target_genes:Optional[numpy.ndarray]=None,\n               query_gene_names:Optional[numpy.ndarray]=None,\n               target_gene_names:Optional[numpy.ndarray]=None)\n\nCalculate which percentage of cells in each cluster express each gene, and translate that to dot size for the dotplot.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nquery\nDataFrame\n\nThe query dataset.\n\n\ntarget\nDataFrame\n\nThe target dataset.\n\n\nquery_clustering\nstr\n\nThe .obs column name to use for the query dataset.\n\n\ntarget_clustering\nstr\n\nThe .obs column name to use for the target dataset.\n\n\nquery_genes\ntyping.Optional[numpy.ndarray]\nNone\nArray of query genes to subset the data, if any. If None, use all genes (default: None).\n\n\ntarget_genes\ntyping.Optional[numpy.ndarray]\nNone\nArray of target genes to subset the data, if any. If None, use all genes (default: None).\n\n\nquery_gene_names\ntyping.Optional[numpy.ndarray]\nNone\nArray of query gene names (default: None).\n\n\ntarget_gene_names\ntyping.Optional[numpy.ndarray]\nNone\nArray of target gene names (default: None).\n\n\nReturns\ntyping.Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]\n\nA tuple containing the dot size values for query and target datasets, respectively.\n\n\n\n\nsource\n\n\nfeature_colors\n\n feature_colors (components:numpy.ndarray, query_G:int, seed:int=42)\n\nAssign colors to the components based on the given array of components.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncomponents\nndarray\n\nThe array of components.\n\n\nquery_G\nint\n\nThe number of components for the query genes.\n\n\nseed\nint\n42\nThe seed value for the random number generator (default: 42).\n\n\nReturns\ntyping.Tuple[numpy.ndarray, numpy.ndarray]\n\nA tuple containing the colored components for query genes and target genes, respectively.\n\n\n\n\nsource\n\n\ngene_order\n\n gene_order (full_adjacency:numpy.ndarray, components:numpy.ndarray,\n             query_G:int)\n\nCalculate the order of genes based on the given full adjacency matrix and components. Highly connected genes are placed first, genes without any connections are randomly ordered in the bottom of the plot.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfull_adjacency\nndarray\nThe full adjacency matrix represented as a 2D numpy array.\n\n\ncomponents\nndarray\nAn array representing the components.\n\n\nquery_G\nint\nThe number of query genes.\n\n\nReturns\ntyping.Tuple[numpy.ndarray, numpy.ndarray]\nA tuple containing the query gene order and the target gene order as numpy arrays.\n\n\n\n\nsource\n\n\ncalculate_adjacency_matrix\n\n calculate_adjacency_matrix (connections:numpy.ndarray,\n                             query_genes:List[Any],\n                             target_genes:List[Any])\n\nCalculate the adjacency matrix based on the given connections, query genes, and target genes.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nconnections\nndarray\nThe 2D array representing the connections between genes. Each row contains two geneidentifiers indicating a connection, and optionally the strength of that connection.\n\n\nquery_genes\ntyping.List[typing.Any]\nA list of genes that act as queries.\n\n\ntarget_genes\ntyping.List[typing.Any]\nA list of genes that act as targets.\n\n\nReturns\nndarray\nThe adjacency matrix represented as a 2D numpy array. It has dimensions (query_G + target_G)x (query_G + target_G), where query_G and target_G are the lengths of query_genes andtarget_genes, respectively.\n\n\n\n\nsource\n\n\nlabel_pos\n\n label_pos (display_coords:Dict[str,Tuple[float,float,float,float]],\n            key:str, side:str='left')\n\nGet the edge coordinates of a label. Keep either the left or the right end of the word.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndisplay_coords\ntyping.Dict[str, typing.Tuple[float, float, float, float]]\n\nA dictionary that holds the window extents of tick labels.\n\n\nkey\nstr\n\nThe label to retrieve; a gene name.\n\n\nside\nstr\nleft\nOne of “left” or “right”; depending on orientation will return the leftmost or rightmostposition of the label (default: “left”).\n\n\nReturns\ntyping.Tuple[float, float]\n\nA tuple containing the x and y coordinates of the label.\n\n\n\n\nsource\n\n\nprepare_dotplot\n\n prepare_dotplot (avg_expr:pandas.core.frame.DataFrame,\n                  perc_expr:pandas.core.frame.DataFrame,\n                  cmap:Union[str,matplotlib.colors.Colormap]='magma_r',\n                  vmin:float=0, vmax:Optional[float]=None,\n                  size_exponent:float=1.5, dot_size:float=200)\n\nPivots average expression and percent expressed tables to make them dotplot-friendly.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\navg_expr\nDataFrame\n\nData frame that holds average expression for all genes and all clusters.\n\n\nperc_expr\nDataFrame\n\nData frame that tracks the percentage of cells expressing each gene in every cluster.\n\n\ncmap\ntyping.Union[str, matplotlib.colors.Colormap]\nmagma_r\nThe Colormap instance or registered colormap name used to map scalar data to colors(default: “magma_r”).\n\n\nvmin\nfloat\n0\nMinimum average expression value to show (default: 0).\n\n\nvmax\ntyping.Optional[float]\nNone\nMaximum average expression value to show (default: maximum average expr. value).\n\n\nsize_exponent\nfloat\n1.5\nDot size is computed as fraction ** size_exponent * dot_size (default: 1.5).\n\n\ndot_size\nfloat\n200\nThe size of the largest dot (default: 200).\n\n\nReturns\ntyping.Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame, numpy.ndarray]\n\nA tuple containing the melted average expression data frame, the melted percentageexpression data frame, and the array of RGBA-coded color values for the average expressionin a cluster/gene combination, according to the input color map.",
    "crumbs": [
      "dotplot_util"
    ]
  },
  {
    "objectID": "plot.html",
    "href": "plot.html",
    "title": "plot",
    "section": "",
    "text": "These functions are intended to help you find your way around the data. I use them a lot when generating reports for collaborators, to set the stage for the more detailed analyses. In particular, I want to highlight which clusters we are comparing and where they are in the context of both species as well as the comparison.\n\nsource\n\n\n\n highlighted_dimplot (adata:anndata._core.anndata.AnnData, species:str,\n                      clustering:str, cluster:str, embedding:str='X_umap',\n                      highlight:str='red', figsize:tuple=(10, 10),\n                      save:Optional[str]=None)\n\nPlot a low-dimensional embedding and highlight a chosen cluster with a superimposed circle.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata\nAnnData\n\nAnnData object to plot.\n\n\nspecies\nstr\n\nSpecies name. Will be used in the title, and removed from the cluster names if present.\n\n\nclustering\nstr\n\nClustering to plot. Must be present in adata.obs.\n\n\ncluster\nstr\n\nCluster to highlight.\n\n\nembedding\nstr\nX_umap\nEmbedding to plot (default: “X_umap”).\n\n\nhighlight\nstr\nred\nColor of the circle (default: “red”).\n\n\nfigsize\ntuple\n(10, 10)\nFigure size (default: (10, 10)).\n\n\nsave\ntyping.Optional[str]\nNone\nPath to save the figure (default: None).\n\n\nReturns\nNone\n\n\n\n\n\n\nplanarian = sc.read_h5ad(os.environ[\"EXAMPLE_DATA_PATH\"] + \"planarian.h5ad\")\nplanarian.var.index = \"pl_\" + planarian.var.index\n\n\nhighlighted_dimplot(planarian, \"Smed\", \"tissue\", \"Pharynx\", figsize=(6, 6))\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n\n\n\n\n\n\n\n\n\nOf course, if a cluster is too spread out, the plot will not work as well, but it will still be useful to see the general location of the cluster.\n\nhighlighted_dimplot(planarian, \"Smed\", \"tissue\", \"Neural\", figsize=(6, 6))\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n\n\n\n\n\n\n\n\n\nAnother case that might not work so well is if the shape of a cluster is not Gaussian. Still, it should help us spot the cluster, especially if the color contrasts enough.\n\nhighlighted_dimplot(\n    planarian, \"Smed\", \"tissue\", \"Muscle\", figsize=(6, 6), highlight=\"lightgreen\"\n)\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\n highlighted_heatmap (to_plot, celltype_from, celltype_to, figheight=20,\n                      save=None)\n\nPlot a heatmap of pairwise similarities between cell types, with a red box highlighting the query cell type.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nto_plot\npd.DataFrame\n\nA dataframe of pairwise similarities between cell types.\n\n\ncelltype_from\nstr\n\nCell type of the query species to highlight. Must be in to_plot.columns.\n\n\ncelltype_to\nstr\n\nCell type of the target species to highlight. Must be in to_plot.index.\n\n\nfigheight\nint\n20\nHeight of the resulting plot in inches. Width will be calculated automatically (default:20).\n\n\nsave\nNoneType\nNone\nPath to result figure; if None, the figure will be plotted but not saved (default: None).\n\n\nReturns\nNone\n\n\n\n\n\n\nhysc = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"hysc_similarity_table.csv\",\n    index_col=0,\n)\n\n\nhighlighted_heatmap(\n    hysc, celltype_from=\"hy_i_SC\", celltype_to=\"sc_Neoblast: 0\", figheight=12\n)\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\n annotated_heatmap (sm:samap.mapping.SAMAP,\n                    similarity:pandas.core.frame.DataFrame,\n                    query_species:str, target_species:str,\n                    query_clustering:str, target_clustering:str,\n                    query_coarse:Optional[str]=None,\n                    target_coarse:Optional[str]=None,\n                    interactive:bool=False,\n                    figsize:Optional[Tuple[float,float]]=None,\n                    save:Optional[str]=None, **kwargs:Any)\n\nPlot the similarity matrix as an annotated heatmap.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsm\nSAMAP\n\nSAMAP object\n\n\nsimilarity\nDataFrame\n\nSimilarity matrix. Contains query species clusters as columns and target species clusters as rows.\n\n\nquery_species\nstr\n\nQuery species ID. Will be used in the title. Should prepend the similarity matrix column names.\n\n\ntarget_species\nstr\n\nTarget species ID. Will be used in the title. Should prepend the similarity matrix row names.\n\n\nquery_clustering\nstr\n\nQuery species clustering. Must be present in sm.sams[query_species].adata.obs.\n\n\ntarget_clustering\nstr\n\nTarget species clustering. Must be present in sm.sams[target_species].adata.obs.\n\n\nquery_coarse\ntyping.Optional[str]\nNone\n\n\n\ntarget_coarse\ntyping.Optional[str]\nNone\nQuery species coarse clustering. Must be present in sm.sams[query_species].adata.obs. If None, will be set to query_clustering (default: None).\n\n\ninteractive\nbool\nFalse\nIf True, will return a plotly figure. Otherwise, will return a matplotlib figure (default: False).\n\n\nfigsize\ntyping.Optional[typing.Tuple[float, float]]\nNone\n\n\n\nsave\ntyping.Optional[str]\nNone\nFigure size. If None, will be guessed from the size of the similarity matrix (default: None).\n\n\nkwargs\ntyping.Any\n\n\n\n\nReturns\ntyping.Optional[plotly.graph_objs._figure.Figure]\n\nIf not None, will save the figure to the specified path (default: None).Additional arguments to pass to seaborn.heatmap (matplotlib) or plotly.graph_objects.Figure (plotly). Among them: dpi (int), which is only used if interactive=True to set the figure size in pixels.\n\n\n\nRead the requisite files: the SAMap object and the pairwise cluster similarity matrix.\n\nfile = open(os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl.pkl\", \"rb\")\nsm = pickle.load(file)\n\nhypl = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl_similarity_table.csv\",\n    index_col=0,\n)\n\nFirst improve the coarse level assignments for the data we have here:\n\nsm.sams[\"hy\"].adata.obs[\"coarse\"] = (\n    sm.sams[\"hy\"].adata.obs[\"Cluster\"].str.split(\"_\").str[0]\n)\nsm.sams[\"pl\"].adata.obs[\"coarse\"] = (\n    sm.sams[\"pl\"].adata.obs[\"tissue_smedwi\"].str.split(\"_\").str[0]\n)\n\n\nannotated_heatmap(\n    sm,\n    hypl,\n    \"hy\",\n    \"pl\",\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_coarse=\"coarse\",\n    target_coarse=\"coarse\",\n    interactive=False,\n    save=\"hypl.pdf\",\n)\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n\n\n\n\n\n\n\n\n\nThis sort of plot does a much better job of showing the relationships between clusters than the Sankey diagram. Clear patches of similarity emerge that would be otherwise invisible. This is a result of the hierarchical relationship between cell types (see Arendt/Musser/Wagner in 2016 and 2019). By combining maps like this with the per-species cell type family trees we can start to get a better idea of how cell types may have evolved over time.\n\nassert os.path.exists(\"hypl.pdf\")\n\nWe can make the same plot in interactive form. Unfortunately, the interactive version is a bit more finicky with color usage, so for now I’ll let plotly choose the colors, but any plotly wizards out there are welcome to improve this. Right now hovering over a point will show the cluster names and SAMap score; hovering over the colored bars at the margins should show the coarse cluster.\n\nplotly_overview = annotated_heatmap(\n    sm,\n    hypl,\n    \"hy\",\n    \"pl\",\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_coarse=\"coarse\",\n    target_coarse=\"coarse\",\n    figsize=(10, 10),\n    interactive=True,\n    dpi=100,\n    save=\"hypl\",\n)\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/var/folders/md/d6lwwbv97xb6g6ddypntnprh0000gp/T/ipykernel_73405/1709870291.py:41: FutureWarning: The behavior of Series.replace (and DataFrame.replace) with CategoricalDtype is deprecated. In a future version, replace will only be used for cases that preserve the categories. To change the categories, use ser.cat.rename_categories instead.\n  query_map[query_coarse] = query_map[query_coarse].replace(to_replace=query_lut)\n/var/folders/md/d6lwwbv97xb6g6ddypntnprh0000gp/T/ipykernel_73405/1709870291.py:42: FutureWarning: The behavior of Series.replace (and DataFrame.replace) with CategoricalDtype is deprecated. In a future version, replace will only be used for cases that preserve the categories. To change the categories, use ser.cat.rename_categories instead.\n  target_map[target_coarse] = target_map[target_coarse].replace(to_replace=target_lut)\n\n\n\nassert os.path.exists(\"hypl.json\")\nassert os.path.exists(\"hypl.html\")\n\nYou can visualize the plot in a notebook with:\n# not run\nplotly_overview.show()",
    "crumbs": [
      "plot"
    ]
  },
  {
    "objectID": "plot.html#see-the-big-picture",
    "href": "plot.html#see-the-big-picture",
    "title": "plot",
    "section": "",
    "text": "These functions are intended to help you find your way around the data. I use them a lot when generating reports for collaborators, to set the stage for the more detailed analyses. In particular, I want to highlight which clusters we are comparing and where they are in the context of both species as well as the comparison.\n\nsource\n\n\n\n highlighted_dimplot (adata:anndata._core.anndata.AnnData, species:str,\n                      clustering:str, cluster:str, embedding:str='X_umap',\n                      highlight:str='red', figsize:tuple=(10, 10),\n                      save:Optional[str]=None)\n\nPlot a low-dimensional embedding and highlight a chosen cluster with a superimposed circle.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata\nAnnData\n\nAnnData object to plot.\n\n\nspecies\nstr\n\nSpecies name. Will be used in the title, and removed from the cluster names if present.\n\n\nclustering\nstr\n\nClustering to plot. Must be present in adata.obs.\n\n\ncluster\nstr\n\nCluster to highlight.\n\n\nembedding\nstr\nX_umap\nEmbedding to plot (default: “X_umap”).\n\n\nhighlight\nstr\nred\nColor of the circle (default: “red”).\n\n\nfigsize\ntuple\n(10, 10)\nFigure size (default: (10, 10)).\n\n\nsave\ntyping.Optional[str]\nNone\nPath to save the figure (default: None).\n\n\nReturns\nNone\n\n\n\n\n\n\nplanarian = sc.read_h5ad(os.environ[\"EXAMPLE_DATA_PATH\"] + \"planarian.h5ad\")\nplanarian.var.index = \"pl_\" + planarian.var.index\n\n\nhighlighted_dimplot(planarian, \"Smed\", \"tissue\", \"Pharynx\", figsize=(6, 6))\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n\n\n\n\n\n\n\n\n\nOf course, if a cluster is too spread out, the plot will not work as well, but it will still be useful to see the general location of the cluster.\n\nhighlighted_dimplot(planarian, \"Smed\", \"tissue\", \"Neural\", figsize=(6, 6))\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n\n\n\n\n\n\n\n\n\nAnother case that might not work so well is if the shape of a cluster is not Gaussian. Still, it should help us spot the cluster, especially if the color contrasts enough.\n\nhighlighted_dimplot(\n    planarian, \"Smed\", \"tissue\", \"Muscle\", figsize=(6, 6), highlight=\"lightgreen\"\n)\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\n highlighted_heatmap (to_plot, celltype_from, celltype_to, figheight=20,\n                      save=None)\n\nPlot a heatmap of pairwise similarities between cell types, with a red box highlighting the query cell type.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nto_plot\npd.DataFrame\n\nA dataframe of pairwise similarities between cell types.\n\n\ncelltype_from\nstr\n\nCell type of the query species to highlight. Must be in to_plot.columns.\n\n\ncelltype_to\nstr\n\nCell type of the target species to highlight. Must be in to_plot.index.\n\n\nfigheight\nint\n20\nHeight of the resulting plot in inches. Width will be calculated automatically (default:20).\n\n\nsave\nNoneType\nNone\nPath to result figure; if None, the figure will be plotted but not saved (default: None).\n\n\nReturns\nNone\n\n\n\n\n\n\nhysc = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"hysc_similarity_table.csv\",\n    index_col=0,\n)\n\n\nhighlighted_heatmap(\n    hysc, celltype_from=\"hy_i_SC\", celltype_to=\"sc_Neoblast: 0\", figheight=12\n)\n\n\n\n\n\n\n\n\n\nsource\n\n\n\n\n annotated_heatmap (sm:samap.mapping.SAMAP,\n                    similarity:pandas.core.frame.DataFrame,\n                    query_species:str, target_species:str,\n                    query_clustering:str, target_clustering:str,\n                    query_coarse:Optional[str]=None,\n                    target_coarse:Optional[str]=None,\n                    interactive:bool=False,\n                    figsize:Optional[Tuple[float,float]]=None,\n                    save:Optional[str]=None, **kwargs:Any)\n\nPlot the similarity matrix as an annotated heatmap.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsm\nSAMAP\n\nSAMAP object\n\n\nsimilarity\nDataFrame\n\nSimilarity matrix. Contains query species clusters as columns and target species clusters as rows.\n\n\nquery_species\nstr\n\nQuery species ID. Will be used in the title. Should prepend the similarity matrix column names.\n\n\ntarget_species\nstr\n\nTarget species ID. Will be used in the title. Should prepend the similarity matrix row names.\n\n\nquery_clustering\nstr\n\nQuery species clustering. Must be present in sm.sams[query_species].adata.obs.\n\n\ntarget_clustering\nstr\n\nTarget species clustering. Must be present in sm.sams[target_species].adata.obs.\n\n\nquery_coarse\ntyping.Optional[str]\nNone\n\n\n\ntarget_coarse\ntyping.Optional[str]\nNone\nQuery species coarse clustering. Must be present in sm.sams[query_species].adata.obs. If None, will be set to query_clustering (default: None).\n\n\ninteractive\nbool\nFalse\nIf True, will return a plotly figure. Otherwise, will return a matplotlib figure (default: False).\n\n\nfigsize\ntyping.Optional[typing.Tuple[float, float]]\nNone\n\n\n\nsave\ntyping.Optional[str]\nNone\nFigure size. If None, will be guessed from the size of the similarity matrix (default: None).\n\n\nkwargs\ntyping.Any\n\n\n\n\nReturns\ntyping.Optional[plotly.graph_objs._figure.Figure]\n\nIf not None, will save the figure to the specified path (default: None).Additional arguments to pass to seaborn.heatmap (matplotlib) or plotly.graph_objects.Figure (plotly). Among them: dpi (int), which is only used if interactive=True to set the figure size in pixels.\n\n\n\nRead the requisite files: the SAMap object and the pairwise cluster similarity matrix.\n\nfile = open(os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl.pkl\", \"rb\")\nsm = pickle.load(file)\n\nhypl = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl_similarity_table.csv\",\n    index_col=0,\n)\n\nFirst improve the coarse level assignments for the data we have here:\n\nsm.sams[\"hy\"].adata.obs[\"coarse\"] = (\n    sm.sams[\"hy\"].adata.obs[\"Cluster\"].str.split(\"_\").str[0]\n)\nsm.sams[\"pl\"].adata.obs[\"coarse\"] = (\n    sm.sams[\"pl\"].adata.obs[\"tissue_smedwi\"].str.split(\"_\").str[0]\n)\n\n\nannotated_heatmap(\n    sm,\n    hypl,\n    \"hy\",\n    \"pl\",\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_coarse=\"coarse\",\n    target_coarse=\"coarse\",\n    interactive=False,\n    save=\"hypl.pdf\",\n)\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n\n\n\n\n\n\n\n\n\nThis sort of plot does a much better job of showing the relationships between clusters than the Sankey diagram. Clear patches of similarity emerge that would be otherwise invisible. This is a result of the hierarchical relationship between cell types (see Arendt/Musser/Wagner in 2016 and 2019). By combining maps like this with the per-species cell type family trees we can start to get a better idea of how cell types may have evolved over time.\n\nassert os.path.exists(\"hypl.pdf\")\n\nWe can make the same plot in interactive form. Unfortunately, the interactive version is a bit more finicky with color usage, so for now I’ll let plotly choose the colors, but any plotly wizards out there are welcome to improve this. Right now hovering over a point will show the cluster names and SAMap score; hovering over the colored bars at the margins should show the coarse cluster.\n\nplotly_overview = annotated_heatmap(\n    sm,\n    hypl,\n    \"hy\",\n    \"pl\",\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_coarse=\"coarse\",\n    target_coarse=\"coarse\",\n    figsize=(10, 10),\n    interactive=True,\n    dpi=100,\n    save=\"hypl\",\n)\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:1234: FutureWarning: The default value of 'ignore' for the `na_action` parameter in pandas.Categorical.map is deprecated and will be changed to 'None' in a future version. Please set na_action to the desired value to avoid seeing this warning\n  color_vector = pd.Categorical(values.map(color_map))\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_tools/scatterplots.py:394: UserWarning: No data for colormapping provided via 'c'. Parameters 'cmap' will be ignored\n  cax = scatter(\n/var/folders/md/d6lwwbv97xb6g6ddypntnprh0000gp/T/ipykernel_73405/1709870291.py:41: FutureWarning: The behavior of Series.replace (and DataFrame.replace) with CategoricalDtype is deprecated. In a future version, replace will only be used for cases that preserve the categories. To change the categories, use ser.cat.rename_categories instead.\n  query_map[query_coarse] = query_map[query_coarse].replace(to_replace=query_lut)\n/var/folders/md/d6lwwbv97xb6g6ddypntnprh0000gp/T/ipykernel_73405/1709870291.py:42: FutureWarning: The behavior of Series.replace (and DataFrame.replace) with CategoricalDtype is deprecated. In a future version, replace will only be used for cases that preserve the categories. To change the categories, use ser.cat.rename_categories instead.\n  target_map[target_coarse] = target_map[target_coarse].replace(to_replace=target_lut)\n\n\n\nassert os.path.exists(\"hypl.json\")\nassert os.path.exists(\"hypl.html\")\n\nYou can visualize the plot in a notebook with:\n# not run\nplotly_overview.show()",
    "crumbs": [
      "plot"
    ]
  },
  {
    "objectID": "plot.html#pairwise-comparisons",
    "href": "plot.html#pairwise-comparisons",
    "title": "plot",
    "section": "Pairwise comparisons",
    "text": "Pairwise comparisons\nWhen comparing two clusters, it is most informative to have a look at the genes they are expressing. If the clusters are in the same species we can use a simple dotplot that combines the two clusters’ marker genes; things are not so simple when comparing between species. By plotting two dotplots side by side, and connecting homologous genes across the dotplots, we can get a better sense of how the clusters are connected.\nA lot of the heavy lifting for this idea was already done by the scanpy team, who write excellent, well-documented code. I’ve adapted their code to produce the paired dotplots, fiddled with it to make sure dot size and color are consistent across plots, and added the homology lines. The latter part is rather tricky, and I would be thankful to anyone who can improve it; currently it involves a lot of heuristics to translate the coordinates from one side of the plot to the other.\n\nsource\n\npaired_dotplot\n\n paired_dotplot (query:anndata._core.anndata.AnnData,\n                 target:anndata._core.anndata.AnnData, connections:&lt;built-\n                 infunctionarray&gt;, query_clustering:str,\n                 target_clustering:str, query_species:str,\n                 target_species:str, query_cluster:Optional[str]=None,\n                 target_cluster:Optional[str]=None, pad:bool=True,\n                 x_offset:float=1, y_offset:float=0, grid_offset:float=30,\n                 query_gene_names:Optional[str]=None,\n                 target_gene_names:Optional[str]=None,\n                 output:str='./paired_dotplot.png', center:bool=True,\n                 title:Optional[str]=None, title_font_size:float=16,\n                 scale:bool=False,\n                 cmap:matplotlib.colors.Colormap='magma_r',\n                 layer:Optional[str]=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nquery\nAnnData\n\nquery species AnnData object\n\n\ntarget\nAnnData\n\ntarget species AnnData object\n\n\nconnections\narray\n\narray of connected genes. Each row has at least two columns containing the query species gene and corresponding target species gene, and optionally their connection strength. Genes are allowed to be repeated on both sides.\n\n\nquery_clustering\nstr\n\n.obs column in the query AnnData object containing the query species clustering.\n\n\ntarget_clustering\nstr\n\n.obs column in the target AnnData object containing the target species clustering.\n\n\nquery_species\nstr\n\nquery species name. Will only be used in the title, so does not have to conform with the query species ID in the similarity matrix/SAMap object.\n\n\ntarget_species\nstr\n\ntarget species name. Will only be used in the title, so does not have to conform with the target species ID in the similarity matrix/SAMap object.\n\n\nquery_cluster\ntyping.Optional[str]\nNone\n\n\n\ntarget_cluster\ntyping.Optional[str]\nNone\nthe cell type/cluster of the query species that is being compared (default: None).\n\n\npad\nbool\nTrue\nwhether to pad the gene names with spaces to make them all of a similar length (default: True).\n\n\nx_offset\nfloat\n1\nNumber of inches to add to the horizontal size of the canvas (default: 1).\n\n\ny_offset\nfloat\n0\nNumber of inches to add to the vertical size of the canvas (default: 0).\n\n\ngrid_offset\nfloat\n30\nGrid segments to add between the two dotplots. Might be useful if the gene names are not legible/lines overlap (default: 30).\n\n\nquery_gene_names\ntyping.Optional[str]\nNone\n\n\n\ntarget_gene_names\ntyping.Optional[str]\nNone\n.var column that holds unique gene names for the query species (default: None).\n\n\noutput\nstr\n./paired_dotplot.png\npath to save the plot to (default: “./paired_dotplot.png”).\n\n\ncenter\nbool\nTrue\nwhether to center the dotplot (default: True).\n\n\ntitle\ntyping.Optional[str]\nNone\noverall title of the plot (default: None).\n\n\ntitle_font_size\nfloat\n16\nfont size of the overall plot title (default: 16).\n\n\nscale\nbool\nFalse\nwhether to scale the expression values to be between 0 and 1 for each gene (default: False).\n\n\ncmap\nColormap\nmagma_r\ncolormap to use for the dotplot (default: “viridis”).\n\n\nlayer\ntyping.Optional[str]\nNone\nlayer : Union[str, None], optional The layer to use for the average expression calculation. If not specified, it will use the .X slot of the AnnData objects. It is vital to set this correctly to avoid calculating average expression on log1p-transformed data (default: None).\n\n\nReturns\nNone\n\n\n\n\n\nRecall that scanpy dotplots need three inputs: the AnnData object, the names of genes to plot, and the name of the clustering. For paired dotplots we need this information for both sides of the plot.\nHowever, genes are input via the connections slot; an array where each row contains two genes and (optionally) the strength of their connection. The function will reorder the genes in order to plot the densely connected gene groups first, and will also color-code each group to make reading the plot easier.\nAdditionally, since plots like this may become busy very fast, the function also accepts the names of the two clusters to be compared; it will then highlight the cluster names in the plot.\nWe are going to prepare the inputs first:\n\nhydra = sm.sams[\"hy\"].adata  # the query dataset\nplanarian = sm.sams[\"pl\"].adata  # the target dataset\nplanarian.raw.var.index = \"pl_\" + planarian.raw.var.index\n\n# the .obs column that contains the cluster labels\nquery_clustering = \"Cluster\"\ntarget_clustering = \"cluster\"\n\n# the species IDs\nquery_species = \"hy\"\ntarget_species = \"pl\"\n\n# the cluster labels to highlight\ncluster_from = \"ecEp_SC2\"\ncluster_to = \"Epidermal: 2\"\n\nThe connections option is provided in this form deliberately, in order to allow the user to decide which genes to connect and how. This may cost a little extra effort for the most common cases, but it means that the function is more flexible.\nThe function currently supports three types of connections, corresponding to connection strength of [0, 1, 2], accordingly. It’s up to the user to assign meaning to the levels. The linestyles that correspond to these are\n\ndotted for 0 (linestyle = (0, (1, 5)))\ndashed for 1 (linestyle = (0, (5, 5)))\nsolid for 2\n\nIn the future I would like to let the user specify the linestyles, but for now this is what we have.\n\n\nClick here for some possible applications\n\n\nwhen comparing a dataset to itself, we could connect a gene to all its paralogs and visualize patterns of paralog substitution in cell type complement of an organism.\n\n\n\nhydra_genes = np.array(\n    [\"hy_t13309aep\", \"hy_t14973aep\", \"hy_t10876aep\", \"hy_t38670aep\", \"hy_t19278aep\"]\n)\nplan_genes = np.array(\n    [\n        \"pl_dd_Smed_v4_361_0_1\",\n        \"pl_dd_Smed_v4_361_0_1\",\n        \"pl_dd_Smed_v4_1215_0_1\",\n        \"pl_dd_Smed_v4_1131_0_1\",\n        \"pl_dd_Smed_v4_1971_0_1\",\n    ]\n)\north_scores = np.array([0, 0, 1, 2, 2])\n\n# connections without orthology scores\nconnections_plain = np.array([hydra_genes, plan_genes]).T\n\n# connections with orthology scores\nconnections_orth = np.array([hydra_genes, plan_genes, orth_scores], dtype=object).T\n\nLet’s have a look at what we feed into the function:\n\npd.DataFrame(connections_plain)\n\n\n\n\n\n\n\n\n\n0\n1\n\n\n\n\n0\nhy_t13309aep\npl_dd_Smed_v4_361_0_1\n\n\n1\nhy_t14973aep\npl_dd_Smed_v4_361_0_1\n\n\n2\nhy_t10876aep\npl_dd_Smed_v4_1215_0_1\n\n\n3\nhy_t38670aep\npl_dd_Smed_v4_1131_0_1\n\n\n4\nhy_t19278aep\npl_dd_Smed_v4_1971_0_1\n\n\n\n\n\n\n\n\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections_plain,\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=cluster_from,\n    target_cluster=cluster_to,\n    pad=False,\n)\n\n\n\n\n\n\n\n\nGene expression can be very different between species, and plotting on the same scale can therefore be misleading. To address this, the function has a scale parameter that will normalize each row (gene) to a range of [0, 1]. This will make the plots more comparable, but it will also obscure the absolute expression levels. Use with caution.\nAnother thing to pay attention to: the scale function is not aware of log-transformed data, so if you applied log1p to your data it will calculate the an average-of-log instead of the log-of-average. This is a problem, and to avoid it please always use a layer that holds raw or normalised counts when using scale=True.\n\nhydra.X.data = np.exp(hydra.X.data) - 1\nhydra.layers[\"norm_counts\"] = hydra.X.copy()\nsc.pp.log1p(hydra)\n\nplanarian.X.data = np.exp(planarian.X.data) - 1\nplanarian.layers[\"norm_counts\"] = planarian.X.copy()\nsc.pp.log1p(planarian)\n\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections_plain,\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=cluster_from,\n    target_cluster=cluster_to,\n    pad=False,\n    scale=True,\n    cmap=\"RdYlBu_r\",\n    layer=\"norm_counts\",\n)\n\n\n\n\n\n\n\n\nSince we didn’t supply any weights for the connections, the function uses a weight of 0, and plots all connections we provided as dotted lines. Let’s try again, this time with weights:\n\n\n\nWARNING - Gene name padding:\n\nWe used pad=False here because we used the gene IDs instead of gene symbols. Gene symbols tend to have the same length, and so pad doesn’t help here. In fact pad=True will throw an issue here, indicating possibly sloppy code. Unfortunately fixing this is not a priority.\n\n\n\npd.DataFrame(connections_orth)\n\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\nhy_t13309aep\npl_dd_Smed_v4_361_0_1\n0\n\n\n1\nhy_t14973aep\npl_dd_Smed_v4_361_0_1\n0\n\n\n2\nhy_t10876aep\npl_dd_Smed_v4_1215_0_1\n1\n\n\n3\nhy_t38670aep\npl_dd_Smed_v4_1131_0_1\n2\n\n\n4\nhy_t19278aep\npl_dd_Smed_v4_1971_0_1\n2\n\n\n\n\n\n\n\n\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections_orth,\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=cluster_from,\n    target_cluster=cluster_to,\n    pad=False,\n    scale=True,\n    cmap=\"RdYlBu_r\",\n    layer=\"norm_counts\",\n)\n\n\n\n\n\n\n\n\nWith weighting we can add an additional layer of information to the plot, such as orthology.\nThe next level would be to include the gene names, making this plot actually useful. For this to work reliably you need to have a column in the .var slot of your AnnData object that contains unique gene names. This is easily achieved by prepending the gene ID to the gene name/description.\nThe following code block is how I usually do this with EggNOG-mapper annotations; feel free to use whatever works for you.\n\n\nCode\nquery = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"eggnog/hydra.tsv\", sep=\"\\t\", engine=\"python\"\n)\n\nquery = query[[\"Unnamed: 0\", \"5\", \"eggNOG_OGs\", \"21\"]].copy()\nquery.columns = [\"gene_id\", \"gene_name\", \"eggNOG_OGs\", \"description\"]\nquery[\"gene_id\"] = \"hy_\" + query[\"gene_id\"].astype(str)\nquery.set_index(\"gene_id\", inplace=True)\nquery[\"name\"] = (\n    query.index.astype(str)\n    + \" | \"\n    + query[\"gene_name\"].fillna(\"\")\n    + \" | \"\n    + query[\"description\"].fillna(\"\")\n)\n\nhydra.var[\"name\"] = hydra.var.index\nhydra.var[\"name\"] = hydra.var[\"name\"].replace(query[\"name\"].to_dict())\n\nhy_t33417aep = \"hy_t33417aep | EPT1 | diacylglycerol cholinephosphotransferase activity\"\nassert hydra.var.loc[\"hy_t33417aep\"][\"name\"] == hy_t33417aep\n\n\nI have now created a column called name in the .var slot of the AnnData object. I can use this to plot the gene names instead of the gene IDs:\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections_orth,\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=cluster_from,\n    target_cluster=cluster_to,\n    query_gene_names=\"name\",\n    scale=True,\n    cmap=\"RdYlBu_r\",\n    layer=\"norm_counts\",\n)\n\n\n\n\n\n\n\n\nThe right side of the plot is left as an exercise to the reader :) Notice how the lines on the left side are not starting from the same spot. This is where the util.procrustes function tries to guess how to pad using space characters so that the plotted strings have approximately the same length and the lines don’t go over some longer gene names. It’s not perfect, but it’s better than nothing.\nFrom here on I will hide the lines of code that stay the same to make the notebook more readable. If you are trying to reproduce the plots, make sure you copy the code from the blocks above and just add the new lines.\nThe other options of the function should be self-explanatory, but I’ll go over them anyway:\n\nx_offset and y_offset control the canvas size beyond the size absolutely necessary for the plots to be rendered correctly. Increase x_offset to give the plots more x-axis space, and y_offset to give them more space on the vertical side. This is not an exact science, and you will find combinations that distort the plot to the point of making it unreadable.\n\n\npaired_dotplot(\n    query=hydra,  # |hide_line\n    target=planarian,  # |hide_line\n    connections=connections_orth,  # |hide_line\n    query_clustering=\"Cluster\",  # |hide_line\n    target_clustering=\"cluster\",  # |hide_line\n    query_species=\"hy\",  # |hide_line\n    target_species=\"pl\",  # |hide_line\n    query_cluster=cluster_from,  # |hide_line\n    target_cluster=cluster_to,  # |hide_line\n    query_gene_names=\"name\",  # |hide_line\n    x_offset=21,\n    y_offset=5,\n    scale=True,\n    cmap=\"RdYlBu_r\",\n)\n\n\n\n\n\n\n\n\nThe grid_offset parameter tries to control the space between the dotplots. Play with it if the lines connecting the genes are too short or too long. Try to stick to odd numbers, for some reason they work better. This gives you an additional lever for when increasing x_offset doesn’t work as intended.\nI will also stop including the scale=True option, but will keep showing different color maps.\n\npaired_dotplot(\n    query=hydra,  # |hide_line\n    target=planarian,  # |hide_line\n    connections=connections_orth,  # |hide_line\n    query_clustering=\"Cluster\",  # |hide_line\n    target_clustering=\"cluster\",  # |hide_line\n    query_species=\"hy\",  # |hide_line\n    target_species=\"pl\",  # |hide_line\n    query_cluster=cluster_from,  # |hide_line\n    target_cluster=cluster_to,  # |hide_line\n    query_gene_names=\"name\",  # |hide_line\n    grid_offset=131,\n    x_offset=21,\n    cmap=\"viridis\"\n)\n\n\n\n\n\n\n\n\n\npaired_dotplot(\n    query=hydra,  # |hide_line\n    target=planarian,  # |hide_line\n    connections=connections_orth,  # |hide_line\n    query_clustering=\"Cluster\",  # |hide_line\n    target_clustering=\"cluster\",  # |hide_line\n    query_species=\"hy\",  # |hide_line\n    target_species=\"pl\",  # |hide_line\n    query_cluster=cluster_from,  # |hide_line\n    target_cluster=cluster_to,  # |hide_line\n    query_gene_names=\"name\",  # |hide_line\n    grid_offset=13,\n    x_offset=21,\n    cmap=\"cividis\",\n)\n\n\n\n\n\n\n\n\nThe parameters title and title_font_size do what you expect them to do.\n\npaired_dotplot(\n    query=hydra,  # |hide_line\n    target=planarian,  # |hide_line\n    connections=connections_orth,  # |hide_line\n    query_clustering=\"Cluster\",  # |hide_line\n    target_clustering=\"cluster\",  # |hide_line\n    query_species=\"hy\",  # |hide_line\n    target_species=\"pl\",  # |hide_line\n    query_cluster=cluster_from,  # |hide_line\n    target_cluster=cluster_to,  # |hide_line\n    query_gene_names=\"name\",  # |hide_line\n    x_offset=31,\n    y_offset=2,\n    title=\"If my title is long and in big font size I need to use the function\\nparameters to make the plot bigger and push the plots to the sides\",\n    title_font_size=40,\n    grid_offset=71,\n    cmap=\"plasma\"\n)\n\n\n\n\n\n\n\n\nFinally, output controls where the plot is saved, and center=True will try to arrange the dotplots so that their centers on the y-axis are aligned. You probably want center=False if you need to print a title.",
    "crumbs": [
      "plot"
    ]
  },
  {
    "objectID": "plot.html#real-life-applications",
    "href": "plot.html#real-life-applications",
    "title": "plot",
    "section": "Real-life applications",
    "text": "Real-life applications\nWhen comparing cell types between species we are mostly interested in figuring out which cell types are homologous, and we want to find conserved gene expression patterns as evidence.\nOne way to get started with this is to look at the top marker genes of a cluster in one species and their homologs in the other animal.\nFor DEG detection I will use logistic regression, since I am interested in finding genes that are specifically expressed in my cluster of interest. I will take the \"enEp_foot\" cluster.\n\nsc.tl.rank_genes_groups(hydra, \"Cluster\", method=\"logreg\")\nsc.tl.rank_genes_groups(planarian, \"cluster\", method=\"logreg\")\n\nFor the sake of illustration let’s have a look at the top 30 genes:\n\ntop30 = hydra.uns[\"rank_genes_groups\"][\"names\"][\"ecEp_SC3\"][:30]\n\n\nsc.pl.dotplot(\n    hydra,\n    hydra.var[\"name\"].loc[top30],\n    gene_symbols=\"name\",\n    groupby=\"Cluster\",\n    cmap=\"magma_r\",\n    swap_axes=True,\n    use_raw=False,\n)\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_dotplot.py:168: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_dotplot.py:178: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_dotplot.py:747: UserWarning:\n\nNo data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n\n\n\n\n\n\n\n\n\n\nThis might be too much information on the plot - many of the true marker genes are only expresed in the endodermal clusters anyway. I would like to collapse the other coarse clusters to make it more legible. I have a function for that:\n\nutil.collapse_unrelated_clusters(hydra, \"ecEp_SC3\", \"Cluster\", \"coarse\")\n\n\nsc.pl.dotplot(\n    hydra,\n    hydra.var[\"name\"].loc[top30],\n    gene_symbols=\"name\",\n    groupby=\"Cluster_collapsed\",\n    cmap=\"magma_r\",\n    swap_axes=True,\n    use_raw=False,\n)\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_dotplot.py:168: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_dotplot.py:178: FutureWarning:\n\nThe default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n/opt/homebrew/Caskroom/mambaforge/base/envs/ascc24/lib/python3.9/site-packages/scanpy/plotting/_dotplot.py:747: UserWarning:\n\nNo data for colormapping provided via 'c'. Parameters 'cmap', 'norm' will be ignored\n\n\n\n\n\n\n\n\n\n\nThis is much more legible. Use this at your own risk though, as it may hide important information.\nNow, let’s find the orthology information for these genes:\n\northology = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl_orthology.tsv\", sep=\"\\t\", index_col=0\n)\n\n\nkeep = np.intersect1d(\n    top30, orthology.index\n)  # for how many genes do we have orthology information?\navailable = orthology.loc[keep]  # subset to only include those\navailable_long = available.reset_index().melt(\n    \"gene_id\"\n)  # pivot the table to long format\navailable_long\n\n\n\n\n\n\n\n\n\ngene_id\nvariable\nvalue\n\n\n\n\n0\nhy_t12447aep\npl_dd_Smed_v4_10001_0_1\n0\n\n\n1\nhy_t12561aep\npl_dd_Smed_v4_10001_0_1\n0\n\n\n2\nhy_t12614aep\npl_dd_Smed_v4_10001_0_1\n0\n\n\n3\nhy_t12863aep\npl_dd_Smed_v4_10001_0_1\n0\n\n\n4\nhy_t14554aep\npl_dd_Smed_v4_10001_0_1\n0\n\n\n...\n...\n...\n...\n\n\n189970\nhy_t25822aep\npl_dd_Smed_v4_99_0_1\n0\n\n\n189971\nhy_t27670aep\npl_dd_Smed_v4_99_0_1\n0\n\n\n189972\nhy_t3105aep\npl_dd_Smed_v4_99_0_1\n0\n\n\n189973\nhy_t3139aep\npl_dd_Smed_v4_99_0_1\n0\n\n\n189974\nhy_t3141aep\npl_dd_Smed_v4_99_0_1\n0\n\n\n\n\n189975 rows × 3 columns\n\n\n\n\nNow we can only keep the pairs with a score greater than zero:\n\nconnections = available_long[available_long[\"value\"] &gt; 0].to_numpy()\n\nWe will now also name the planarian genes so that the plot makes more sense:\n\n\nCode\ntarget = pd.read_csv(\n    os.environ[\"EXAMPLE_DATA_PATH\"] + \"eggnog/planarian.tsv\", sep=\"\\t\", engine=\"python\"\n)\n\ntarget = target[[\"Unnamed: 0\", \"5\", \"eggNOG_OGs\", \"21\"]].copy()\ntarget.columns = [\"gene_id\", \"gene_name\", \"eggNOG_OGs\", \"description\"]\ntarget[\"gene_id\"] = \"pl_\" + target[\"gene_id\"].astype(str)\ntarget.set_index(\"gene_id\", inplace=True)\ntarget[\"name\"] = (\n    target.index.astype(str)\n    + \" | \"\n    + target[\"gene_name\"].fillna(\"\")\n    + \" | \"\n    + target[\"description\"].fillna(\"\")\n)\n\nplanarian.var[\"name\"] = planarian.var.index\nplanarian.var[\"name\"] = planarian.var[\"name\"].replace(target[\"name\"].to_dict())\n\n\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections,\n    query_clustering=\"Cluster_collapsed\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=\"ecEp_SC3\",\n    target_cluster=\"Epidermal: 2\",\n    query_gene_names=\"name\",\n    target_gene_names=\"name\",\n    x_offset=15,\n)\n\n\n\n\n\n\n\n\nThis approach will be sensitive but not very specific, as we will be plotting entire gene families on the target side. A more specific approach would be to look for genes that are markers on both sides and also homologous:\n\nhydra_top100 = hydra.uns[\"rank_genes_groups\"][\"names\"][\"ecEp_SC3\"][:100]\nplanarian_top100 = planarian.uns[\"rank_genes_groups\"][\"names\"][\"Epidermal: 2\"][:100]\n\n\nconnections = genes.get_orthologs_overlap(\n    hydra_top100, planarian_top100, hydra, planarian, orthology\n)\n\n\nconnections\n\narray([['hy_t10711aep', 'pl_dd_Smed_v4_299_0_1', '1'],\n       ['hy_t10711aep', 'pl_dd_Smed_v4_414_0_1', '1'],\n       ['hy_t22760aep', 'pl_dd_Smed_v4_433_0_1', '1'],\n       ['hy_t22760aep', 'pl_dd_Smed_v4_7131_0_1', '1'],\n       ['hy_t22760aep', 'pl_dd_Smed_v4_762_0_1', '1']], dtype='&lt;U22')\n\n\n\npaired_dotplot(\n    query=hydra,\n    target=planarian,\n    connections=connections,\n    query_clustering=\"Cluster\",\n    target_clustering=\"cluster\",\n    query_species=\"hy\",\n    target_species=\"pl\",\n    query_cluster=\"ecEp_SC3\",\n    target_cluster=\"Epidermal: 2\",\n    query_gene_names=\"name\",\n    target_gene_names=\"name\",\n    pad=False,\n    x_offset=-5,\n)\n\n\n\n\n\n\n\n\nI clearly chose the wrong example here, but I hope you can see the idea behind the method, and how that could be useful when analysing your own data. Hopefully by comparing two species that are somewhat closer related than Hydra and Schmidtea.\nOr, since the methods I describe here are so flexible, you could use them to manually compile lists of marker genes and visualize those, to much greater effect than this half-baked attempt at finding needles in a haystack. You probably know your favorite species much better than I know Hydra and Schmidtea, after all!\nOr, and hear me out here, cnidarians might have a fundamentally different way of building their cell types compared to other metazoans, and so SAMap can’t find bonafide homologs. If we do all the pairwise comparisons and can’t find compelling evidence for homology, we can start to think about alternatives.\n\n\n\nDISCLAIMER\n\nYes, I know that cnidarians and the rest of the metazoans had a common origin and that there is compelling evidence that many of their cell types are probably, in fact, homologous. I also know your in-situ data probably shows stuff that slightly disagrees with the single-cell data. I am just using hyperbole to make a point. Please don’t sue me.",
    "crumbs": [
      "plot"
    ]
  },
  {
    "objectID": "util.html",
    "href": "util.html",
    "title": "util",
    "section": "",
    "text": "source\n\nprocrustes\n\n procrustes (x:str, appropriate_length:int=50, pad_with:str=' ',\n             side:str='right')\n\nA function to regulate string length.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx\nstr\n\ninput string\n\n\nappropriate_length\nint\n50\ndesired length\n\n\npad_with\nstr\n\ncharacter to pad with\n\n\nside\nstr\nright\nwhich side to pad on (“left”, “right”)\n\n\nReturns\nstr\n\nstring with desired length\n\n\n\nWe are primarily going to be working with non-model species, so the gene names will always be of the form\nXLOC_123456 | emapper-name-or-description-if-we're-lucky\nor something similar. This means that we could have extreme variation in the actual length of a gene “name”; this will make it very hard to put gene names on axes as it will distort figure sizes. I wrote a function to either trim or pad strings; even though axis labels are not in monospace fonts, it is much easier to visually reconcile strings with lengths in the same order of magnitude.\n\ntoo_short = \"Niko\"\njust_right = \"Theseus\"\ntoo_tall = \"The Mountain\"\n\n\nassert procrustes(just_right, appropriate_length=7) == \"Theseus\"\nassert procrustes(too_short, appropriate_length=7) == \"Niko   \"\nassert procrustes(too_tall, appropriate_length=7) == \"The Mou\"\n\n\nsource\n\n\ngrouped_obs_mean\n\n grouped_obs_mean (adata:anndata._core.anndata.AnnData, group_key:str,\n                   layer:Optional[str]=None)\n\nHelper function to calculate average expression per group in an AnnData object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata\nAnnData\n\nAnnData object to analyse\n\n\ngroup_key\nstr\n\n.obs category to group by\n\n\nlayer\ntyping.Optional[str]\nNone\nlayer to use. If none, use .X\n\n\nReturns\nDataFrame\n\na groups\\(\\times\\)genes dataframe with the average expression\n\n\n\nMany tasks in single-cell analysis require us to know the average expression of a gene in a certain group of cells. While scanpy does perform that task behind the scenes for, e.g. dotplots, this is not functionality that is exposed to the users. This is an implementation based on ivirshup’s answer to a scanpy issue.\n\nadata = sc.read_h5ad(os.environ[\"EXAMPLE_DATA_PATH\"] + \"hydra.h5ad\")\n\ncluster_means = grouped_obs_mean(adata, group_key=\"Cluster\")\n\nIf \\(G\\) is the number of genes and \\(C\\) the number of unique clusters in the group_key, the returned array should have the shape \\(G \\times C\\):\n\nno_genes = adata.shape[1]\nno_clusters = len(np.unique(adata.obs[\"Cluster\"]))\nassert cluster_means.shape == (no_genes, no_clusters)\n\nAdditionally, each column of the array should contain the average detected expression for cells in that cluster:\n\nbelong_to_ecEp_SC2 = adata.obs[\"Cluster\"] == \"ecEp_SC2\"\necEp_SC2_average = np.mean(adata[belong_to_ecEp_SC2].X, axis=0)\necEp_SC2_average = np.array(ecEp_SC2_average)[0]\n\nassert all(np.isclose(cluster_means[\"ecEp_SC2\"], ecEp_SC2_average))\n\n\nsource\n\n\ngrouped_obs_present\n\n grouped_obs_present (adata, group_key, layer:Optional[str]=None)\n\nHelper function to calculate how many cells express each gene per group in an AnnData object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata\nAnnData\n\nAnnData object to analyse.\n\n\ngroup_key\nstr\n\n.obs category to group by.\n\n\nlayer\ntyping.Optional[str]\nNone\nLayer to use. If none, use .X.\n\n\nReturns\npd.DataFrame\n\nA clusters$ imes$genes dataframe with the number of expressing cells per cluster.\n\n\n\nAnother critical value to know when making dotplots is the fraction of cells expressing a gene in a certain cluster. Again, scanpy performs that task without exposing it to the users. Similar to [grouped_obs_mean](https://galicae.github.io/comandos/util.html#grouped_obs_mean) this is an implementation based on ivirshup’s answer to a scanpy issue. Here we calculate the sum of cells expressing a gene, a table we can use to calculate the fraction later.\n\nnum_expressing = grouped_obs_present(adata, group_key=\"Cluster\")\n\nIf \\(G\\) is the number of genes and \\(C\\) the number of unique clusters in the group_key, the returned array should have the shape \\(G \\times C\\):\n\nassert num_expressing.shape == (no_genes, no_clusters)\n\nAdditionally, each column of the array should contain the percentage of cells expressing each gene in that cluster:\n\nbelong_to_ecEp_SC2 = adata.obs[\"Cluster\"] == \"ecEp_SC2\"\necEp_SC2_expr = np.sum(adata[belong_to_ecEp_SC2].X &gt; 0, axis=0)\necEp_SC2_expr = np.array(ecEp_SC2_expr)[0]\n\nassert all(num_expressing[\"ecEp_SC2\"] == ecEp_SC2_expr)\n\n\nsource\n\n\ngrouped_obs_percent\n\n grouped_obs_percent (adata, group_key, layer:Optional[str]=None)\n\nHelper function to calculate what percentage of cells express each gene per group in an AnnData object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata\nAnnData\n\nAnnData object to analyse.\n\n\ngroup_key\nstr\n\n.obs category to group by.\n\n\nlayer\ntyping.Optional[str]\nNone\nLayer to use. If none, use .X.\n\n\nReturns\npd.DataFrame\n\nA clusters$ imes$genes dataframe with the percentage of expressing cells per cluster.\n\n\n\nCalculating the fraction of cells is of course very straightforward once we have counted the number of cells that express the gene as well as the total number of cells in a cluster.\n\nfrac_expressing = grouped_obs_percent(adata, group_key=\"Cluster\")\n# use the counts and number of cells we calculated before\nfrac_ecEp_SC2 = ecEp_SC2_expr / np.sum(belong_to_ecEp_SC2)\n\nassert all(np.isclose(frac_expressing[\"ecEp_SC2\"], frac_ecEp_SC2))\n\nWhen visualising gene expression in the context of single-cell RNA-seq comparisons between species, absolute expression values are meaningless, as there are too many factors that determine them that we can not account for. It is sometimes more informative to look at the relative expression of a gene within the organism, i.e. to look at it in terms of min/max expression.\nScanpy does not have a provision for this, so here is a small utility function that does that:\n\nsource\n\n\nrescale\n\n rescale (x:pandas.core.frame.DataFrame)\n\nRescale a dataframe so that row values are in the range [0, 1].\n\n\n\n\nType\nDetails\n\n\n\n\nx\nDataFrame\nA two-dimensional array to rescale; preferably the output of grouped_obs_mean.\n\n\nReturns\nDataFrame\nthe rescaled dataframe.\n\n\n\n\n\nHighlighting clusters\nDimensionality reduction plots can often be rather busy, and searching for the correct cluster can be a bit of a hassle. It would be great if we could highlight the cluster of interest without losing the rest of the clustering information; for instance by drawing a circle around the cluster to highlight.\n\nsource\n\n\nfind_center\n\n find_center (coords)\n\nA function that estimates a Gaussian probability density for the input data and returns the mode. From https://stackoverflow.com/a/60185876.\n\n\n\n\nType\nDetails\n\n\n\n\ncoords\nnp.ndarray\nA 2D array with X, Y-coordinates from xs, ys.\n\n\nReturns\nfloat\nThe X-coordinate of the mode.\n\n\n\nA heuristic to achieve this is to pretend the cluster points are a Gaussian cloud on UMAP/tSNE/PCA/&lt;your favorite embedding&gt; space, and take the position with the highest density (the mode of the 2D distribution). This function is inspired from a StackOverflow answer, and mostly a wrapper around the Gaussian KDE function from scikit-learn.\n\n# create a random number generator\nrng = np.random.default_rng(42)\n# create a 2D Gaussian dataset\nx = rng.normal(loc=2, scale=1, size=2000)\ny = rng.normal(loc=-2, scale=1, size=2000)\n\ncoords = np.array([x, y]).T\n\n\ncoords_center = find_center(coords)\n\nWe’d expect the mode of the kernel density estimate to be very close to the true mean of the data. Since this is for plotting purposes we don’t need to be extremely specific. See plot:highlighted_dimplot for a demonstration of the function.\n\nassert np.isclose(coords_center[0], 2, rtol=0.2)\nassert np.isclose(coords_center[1], -2, rtol=0.2)\n\n\nsource\n\n\nmap_fine_to_coarse\n\n map_fine_to_coarse (sm, species, fine, coarse=None, plot=&lt;function umap&gt;,\n                     include_coarse=False)\n\nExtract the mapping of fine to coarse clusters from a SAMap object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsm\nsm.maps.SAMAP\n\nSAMAP object to process.\n\n\nspecies\nstr\n\nSpecies ID of the correct SAM object.\n\n\nfine\nstr\n\nFine clustering slot name.\n\n\ncoarse\nNoneType\nNone\nCoarse clustering slot name. If None, use the same as fine, mapping each cluster toitself. (default: None).\n\n\nplot\nfunction\numap\nPlotting function to use; this will correctly set the colors (default: sc.pl.umap).\n\n\ninclude_coarse\nbool\nFalse\nIf True, preface the fine cluster names with the coarse cluster names (default: False).\n\n\nReturns\nfine_to_coarse: pd.DataFrame\n\nA dataframe with the mapping of fine to coarse clusters.\n\n\n\n/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/fastcore/docscrape.py:225: UserWarning: potentially wrong underline length... \nModifies \n------- in \nThis function collapses unrelated clusters by identifying a major cluster category based on the\n`coarse` column. It then assigns the major cluster category to all unrelated clusters in the...\n  else: warn(msg)\n\nsource\n\n\ncollapse_unrelated_clusters\n\n collapse_unrelated_clusters (adata:anndata._core.anndata.AnnData,\n                              cluster:str, fine:str, coarse:str)\n\nThis function collapses unrelated clusters by identifying a major cluster category based on the coarse column. It then assigns the major cluster category to all unrelated clusters in the fine column. The resulting collapsed cluster information is stored in a new column named fine + \"_collapsed\".\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nadata\nAnnData\nThe annotation data containing the clusters to be collapsed.\n\n\ncluster\nstr\nThe cluster identifier within the fine column that needs to be collapsed.\n\n\nfine\nstr\nThe column name representing the fine-grained clustering.\n\n\ncoarse\nstr\nThe column name representing the coarse-grained clustering.\n\n\nReturns\nNone\n\n\n\n\n\nfile = open(os.environ[\"EXAMPLE_DATA_PATH\"] + \"hypl.pkl\", \"rb\")\nsm = pickle.load(file)\n\nsm.sams[\"hy\"].adata.obs[\"coarse\"] = (\n    sm.sams[\"hy\"].adata.obs[\"Cluster\"].str.split(\"_\").str[0]\n)\n\n\ncollapse_unrelated_clusters(sm.sams[\"hy\"].adata, \"ecEp_SC2\", \"Cluster\", \"coarse\")\n\n\nsm.sams[\"hy\"].adata.obs[\"Cluster\"].cat.categories\n\nIndex(['ecEp_SC2', 'ecEp_SC3', 'ecEp_bat1(mp)', 'ecEp_bat2(mp)', 'ecEp_bd',\n       'ecEp_head', 'ecEp_nem1(pd)', 'ecEp_nem2(id)', 'enEp_SC1', 'enEp_SC2',\n       'enEp_SC3', 'enEp_foot', 'enEp_head', 'enEp_nem1(pd)', 'enEp_nem2(pd)',\n       'enEp_tent', 'enEp_tent(pd)', 'i_SC', 'i_fmgl1', 'i_fmgl2_nurse',\n       'i_gmgc', 'i_mgl', 'i_nb1', 'i_nb2', 'i_nb3', 'i_nb4', 'i_nc1', 'i_nc2',\n       'i_nc3', 'i_nc4', 'i_nc5', 'i_nc6', 'i_nc7', 'i_nc8', 'i_nc_gc_prog',\n       'i_nc_prog', 'i_nem', 'i_smgc1', 'i_smgc2', 'i_zmg1', 'i_zmg2', 'nan'],\n      dtype='object')\n\n\n\nsm.sams[\"hy\"].adata.obs[\"Cluster_collapsed\"].cat.categories\n\nIndex(['ecEp_SC2', 'ecEp_SC3', 'ecEp_bat1(mp)', 'ecEp_bat2(mp)', 'ecEp_bd',\n       'ecEp_head', 'ecEp_nem1(pd)', 'ecEp_nem2(id)', 'enEp', 'i', 'nan'],\n      dtype='object')\n\n\nNotice that all subclusters in the \"ecEP\" group are still visible, but all other clusters are subsumed by their coarse cluster.",
    "crumbs": [
      "util"
    ]
  }
]