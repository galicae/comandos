<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Collection of helper functions to facilitate plotting">

<title>comandos - util</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="comandos - util">
<meta property="og:description" content="Collection of helper functions to facilitate plotting">
<meta property="og:site_name" content="comandos">
<meta name="twitter:title" content="comandos - util">
<meta name="twitter:description" content="Collection of helper functions to facilitate plotting">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">comandos</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./util.html">util</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ComAnDOS</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./util.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">util</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./genes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">genes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./plot.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">plot</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./dotplot_util.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">dotplot_util</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./report.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">report</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#procrustes" id="toc-procrustes" class="nav-link active" data-scroll-target="#procrustes">procrustes</a></li>
  <li><a href="#grouped_obs_mean" id="toc-grouped_obs_mean" class="nav-link" data-scroll-target="#grouped_obs_mean">grouped_obs_mean</a></li>
  <li><a href="#grouped_obs_present" id="toc-grouped_obs_present" class="nav-link" data-scroll-target="#grouped_obs_present">grouped_obs_present</a></li>
  <li><a href="#grouped_obs_percent" id="toc-grouped_obs_percent" class="nav-link" data-scroll-target="#grouped_obs_percent">grouped_obs_percent</a></li>
  <li><a href="#rescale" id="toc-rescale" class="nav-link" data-scroll-target="#rescale">rescale</a></li>
  <li><a href="#highlighting-clusters" id="toc-highlighting-clusters" class="nav-link" data-scroll-target="#highlighting-clusters">Highlighting clusters</a></li>
  <li><a href="#find_center" id="toc-find_center" class="nav-link" data-scroll-target="#find_center">find_center</a></li>
  <li><a href="#map_fine_to_coarse" id="toc-map_fine_to_coarse" class="nav-link" data-scroll-target="#map_fine_to_coarse">map_fine_to_coarse</a></li>
  <li><a href="#collapse_unrelated_clusters" id="toc-collapse_unrelated_clusters" class="nav-link" data-scroll-target="#collapse_unrelated_clusters">collapse_unrelated_clusters</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/galicae/comandos/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">util</h1>
</div>

<div>
  <div class="description">
    Collection of helper functions to facilitate plotting
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<hr>
<p><a href="https://github.com/galicae/comandos/blob/main/comandos/util.py#L26" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="procrustes" class="level3">
<h3 class="anchored" data-anchor-id="procrustes">procrustes</h3>
<blockquote class="blockquote">
<pre><code> procrustes (x:str, appropriate_length:int=50, pad_with:str=' ',
             side:str='right')</code></pre>
</blockquote>
<p>A function to regulate string length.</p>
<table class="table">
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x</td>
<td>str</td>
<td></td>
<td>input string</td>
</tr>
<tr class="even">
<td>appropriate_length</td>
<td>int</td>
<td>50</td>
<td>desired length</td>
</tr>
<tr class="odd">
<td>pad_with</td>
<td>str</td>
<td></td>
<td>character to pad with</td>
</tr>
<tr class="even">
<td>side</td>
<td>str</td>
<td>right</td>
<td>which side to pad on (“left”, “right”)</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>str</strong></td>
<td></td>
<td><strong>string with desired length</strong></td>
</tr>
</tbody>
</table>
<p>We are primarily going to be working with non-model species, so the gene names will always be of the form</p>
<p><code>XLOC_123456 | emapper-name-or-description-if-we're-lucky</code></p>
<p>or something similar. This means that we could have extreme variation in the actual length of a gene “name”; this will make it very hard to put gene names on axes as it will distort figure sizes. I wrote a function to either trim or pad strings; even though axis labels are not in monospace fonts, it is much easier to visually reconcile strings with lengths in the same order of magnitude.</p>
<div id="cell-4" class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>too_short <span class="op">=</span> <span class="st">"Niko"</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>just_right <span class="op">=</span> <span class="st">"Theseus"</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>too_tall <span class="op">=</span> <span class="st">"The Mountain"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-5" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> procrustes(just_right, appropriate_length<span class="op">=</span><span class="dv">7</span>) <span class="op">==</span> <span class="st">"Theseus"</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> procrustes(too_short, appropriate_length<span class="op">=</span><span class="dv">7</span>) <span class="op">==</span> <span class="st">"Niko   "</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> procrustes(too_tall, appropriate_length<span class="op">=</span><span class="dv">7</span>) <span class="op">==</span> <span class="st">"The Mou"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<p><a href="https://github.com/galicae/comandos/blob/main/comandos/util.py#L47" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="grouped_obs_mean" class="level3">
<h3 class="anchored" data-anchor-id="grouped_obs_mean">grouped_obs_mean</h3>
<blockquote class="blockquote">
<pre><code> grouped_obs_mean (adata:anndata._core.anndata.AnnData, group_key:str,
                   layer:Optional[str]=None)</code></pre>
</blockquote>
<p>Helper function to calculate average expression per group in an <code>AnnData</code> object.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>adata</td>
<td>AnnData</td>
<td></td>
<td>AnnData object to analyse</td>
</tr>
<tr class="even">
<td>group_key</td>
<td>str</td>
<td></td>
<td><code>.obs</code> category to group by</td>
</tr>
<tr class="odd">
<td>layer</td>
<td>typing.Optional[str]</td>
<td>None</td>
<td>layer to use. If none, use <code>.X</code></td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>DataFrame</strong></td>
<td></td>
<td><strong>a groups<span class="math inline">\(\times\)</span>genes dataframe with the average expression</strong></td>
</tr>
</tbody>
</table>
<p>Many tasks in single-cell analysis require us to know the average expression of a gene in a certain group of cells. While <code>scanpy</code> <em>does</em> perform that task behind the scenes for, e.g.&nbsp;dotplots, this is not functionality that is exposed to the users. This is an implementation based on <a href="https://github.com/theislab/scanpy/issues/181#issuecomment-534867254">ivirshup’s answer</a> to a scanpy issue.</p>
<div id="cell-8" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>adata <span class="op">=</span> sc.read_h5ad(os.environ[<span class="st">"EXAMPLE_DATA_PATH"</span>] <span class="op">+</span> <span class="st">"hydra.h5ad"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>cluster_means <span class="op">=</span> grouped_obs_mean(adata, group_key<span class="op">=</span><span class="st">"Cluster"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If <span class="math inline">\(G\)</span> is the number of genes and <span class="math inline">\(C\)</span> the number of unique clusters in the <code>group_key</code>, the returned array should have the shape <span class="math inline">\(G \times C\)</span>:</p>
<div id="cell-10" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>no_genes <span class="op">=</span> adata.shape[<span class="dv">1</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>no_clusters <span class="op">=</span> <span class="bu">len</span>(np.unique(adata.obs[<span class="st">"Cluster"</span>]))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> cluster_means.shape <span class="op">==</span> (no_genes, no_clusters)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Additionally, each column of the array should contain the average detected expression for cells in that cluster:</p>
<div id="cell-12" class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>belong_to_ecEp_SC2 <span class="op">=</span> adata.obs[<span class="st">"Cluster"</span>] <span class="op">==</span> <span class="st">"ecEp_SC2"</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>ecEp_SC2_average <span class="op">=</span> np.mean(adata[belong_to_ecEp_SC2].X, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>ecEp_SC2_average <span class="op">=</span> np.array(ecEp_SC2_average)[<span class="dv">0</span>]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">all</span>(np.isclose(cluster_means[<span class="st">"ecEp_SC2"</span>], ecEp_SC2_average))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<p><a href="https://github.com/galicae/comandos/blob/main/comandos/util.py#L71" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="grouped_obs_present" class="level3">
<h3 class="anchored" data-anchor-id="grouped_obs_present">grouped_obs_present</h3>
<blockquote class="blockquote">
<pre><code> grouped_obs_present (adata, group_key, layer:Optional[str]=None)</code></pre>
</blockquote>
<p>Helper function to calculate how many cells express each gene per group in an <code>AnnData</code> object.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>adata</td>
<td>AnnData</td>
<td></td>
<td>AnnData object to analyse.</td>
</tr>
<tr class="even">
<td>group_key</td>
<td>str</td>
<td></td>
<td><code>.obs</code> category to group by.</td>
</tr>
<tr class="odd">
<td>layer</td>
<td>typing.Optional[str]</td>
<td>None</td>
<td>Layer to use. If none, use <code>.X</code>.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>pd.DataFrame</strong></td>
<td></td>
<td><strong>A clusters$ imes$genes dataframe with the number of expressing cells per cluster.</strong></td>
</tr>
</tbody>
</table>
<p>Another critical value to know when making dotplots is the fraction of cells expressing a gene in a certain cluster. Again, <code>scanpy</code> performs that task without exposing it to the users. Similar to <a href="#grouped_obs_mean">[<code>grouped_obs_mean</code>](https://galicae.github.io/comandos/util.html#grouped_obs_mean)</a> this is an implementation based on <a href="https://github.com/theislab/scanpy/issues/181#issuecomment-534867254">ivirshup’s answer</a> to a scanpy issue. Here we calculate the sum of cells expressing a gene, a table we can use to calculate the fraction later.</p>
<div id="cell-15" class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>num_expressing <span class="op">=</span> grouped_obs_present(adata, group_key<span class="op">=</span><span class="st">"Cluster"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If <span class="math inline">\(G\)</span> is the number of genes and <span class="math inline">\(C\)</span> the number of unique clusters in the <code>group_key</code>, the returned array should have the shape <span class="math inline">\(G \times C\)</span>:</p>
<div id="cell-17" class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> num_expressing.shape <span class="op">==</span> (no_genes, no_clusters)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Additionally, each column of the array should contain the percentage of cells expressing each gene in that cluster:</p>
<div id="cell-19" class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>belong_to_ecEp_SC2 <span class="op">=</span> adata.obs[<span class="st">"Cluster"</span>] <span class="op">==</span> <span class="st">"ecEp_SC2"</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>ecEp_SC2_expr <span class="op">=</span> np.<span class="bu">sum</span>(adata[belong_to_ecEp_SC2].X <span class="op">&gt;</span> <span class="dv">0</span>, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>ecEp_SC2_expr <span class="op">=</span> np.array(ecEp_SC2_expr)[<span class="dv">0</span>]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">all</span>(num_expressing[<span class="st">"ecEp_SC2"</span>] <span class="op">==</span> ecEp_SC2_expr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<p><a href="https://github.com/galicae/comandos/blob/main/comandos/util.py#L107" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="grouped_obs_percent" class="level3">
<h3 class="anchored" data-anchor-id="grouped_obs_percent">grouped_obs_percent</h3>
<blockquote class="blockquote">
<pre><code> grouped_obs_percent (adata, group_key, layer:Optional[str]=None)</code></pre>
</blockquote>
<p>Helper function to calculate what percentage of cells express each gene per group in an <code>AnnData</code> object.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>adata</td>
<td>AnnData</td>
<td></td>
<td>AnnData object to analyse.</td>
</tr>
<tr class="even">
<td>group_key</td>
<td>str</td>
<td></td>
<td><code>.obs</code> category to group by.</td>
</tr>
<tr class="odd">
<td>layer</td>
<td>typing.Optional[str]</td>
<td>None</td>
<td>Layer to use. If none, use <code>.X</code>.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>pd.DataFrame</strong></td>
<td></td>
<td><strong>A clusters$ imes$genes dataframe with the percentage of expressing cells per cluster.</strong></td>
</tr>
</tbody>
</table>
<p>Calculating the fraction of cells is of course very straightforward once we have counted the number of cells that express the gene as well as the total number of cells in a cluster.</p>
<div id="cell-22" class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>frac_expressing <span class="op">=</span> grouped_obs_percent(adata, group_key<span class="op">=</span><span class="st">"Cluster"</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co"># use the counts and number of cells we calculated before</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>frac_ecEp_SC2 <span class="op">=</span> ecEp_SC2_expr <span class="op">/</span> np.<span class="bu">sum</span>(belong_to_ecEp_SC2)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> <span class="bu">all</span>(np.isclose(frac_expressing[<span class="st">"ecEp_SC2"</span>], frac_ecEp_SC2))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>When visualising gene expression in the context of single-cell RNA-seq comparisons between species, absolute expression values are meaningless, as there are too many factors that determine them that we can not account for. It is sometimes more informative to look at the relative expression of a gene within the organism, i.e.&nbsp;to look at it in terms of min/max expression.</p>
<p>Scanpy does not have a provision for this, so here is a small utility function that does that:</p>
<hr>
<p><a href="https://github.com/galicae/comandos/blob/main/comandos/util.py#L131" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="rescale" class="level3">
<h3 class="anchored" data-anchor-id="rescale">rescale</h3>
<blockquote class="blockquote">
<pre><code> rescale (x:pandas.core.frame.DataFrame)</code></pre>
</blockquote>
<p>Rescale a dataframe so that row values are in the range [0, 1].</p>
<table class="table">
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x</td>
<td>DataFrame</td>
<td>A two-dimensional array to rescale; preferably the output of <a href="https://galicae.github.io/comandos/util.html#grouped_obs_mean"><code>grouped_obs_mean</code></a>.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>DataFrame</strong></td>
<td><strong>the rescaled dataframe.</strong></td>
</tr>
</tbody>
</table>
</section>
<section id="highlighting-clusters" class="level3">
<h3 class="anchored" data-anchor-id="highlighting-clusters">Highlighting clusters</h3>
<p>Dimensionality reduction plots can often be rather busy, and searching for the correct cluster can be a bit of a hassle. It would be great if we could highlight the cluster of interest without losing the rest of the clustering information; for instance by drawing a circle around the cluster to highlight.</p>
<hr>
<p><a href="https://github.com/galicae/comandos/blob/main/comandos/util.py#L151" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="find_center" class="level3">
<h3 class="anchored" data-anchor-id="find_center">find_center</h3>
<blockquote class="blockquote">
<pre><code> find_center (coords)</code></pre>
</blockquote>
<p>A function that estimates a Gaussian probability density for the input data and returns the mode. From https://stackoverflow.com/a/60185876.</p>
<table class="table">
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>coords</td>
<td>np.ndarray</td>
<td>A 2D array with X, Y-coordinates from xs, ys.</td>
</tr>
<tr class="even">
<td><strong>Returns</strong></td>
<td><strong>float</strong></td>
<td><strong>The X-coordinate of the mode.</strong></td>
</tr>
</tbody>
</table>
<p>A heuristic to achieve this is to pretend the cluster points are a Gaussian cloud on UMAP/tSNE/PCA/&lt;your favorite embedding&gt; space, and take the position with the highest density (the mode of the 2D distribution). This function is inspired from a <a href="https://stackoverflow.com/a/60185876">StackOverflow answer</a>, and mostly a wrapper around the <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html">Gaussian KDE</a> function from <code>scikit-learn</code>.</p>
<div id="cell-28" class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a random number generator</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(<span class="dv">42</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># create a 2D Gaussian dataset</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> rng.normal(loc<span class="op">=</span><span class="dv">2</span>, scale<span class="op">=</span><span class="dv">1</span>, size<span class="op">=</span><span class="dv">2000</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> rng.normal(loc<span class="op">=-</span><span class="dv">2</span>, scale<span class="op">=</span><span class="dv">1</span>, size<span class="op">=</span><span class="dv">2000</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> np.array([x, y]).T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-29" class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>coords_center <span class="op">=</span> find_center(coords)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We’d expect the mode of the kernel density estimate to be very close to the true mean of the data. Since this is for plotting purposes we don’t need to be extremely specific. See <code>plot:highlighted_dimplot</code> for a demonstration of the function.</p>
<div id="cell-31" class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.isclose(coords_center[<span class="dv">0</span>], <span class="dv">2</span>, rtol<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.isclose(coords_center[<span class="dv">1</span>], <span class="op">-</span><span class="dv">2</span>, rtol<span class="op">=</span><span class="fl">0.2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<p><a href="https://github.com/galicae/comandos/blob/main/comandos/util.py#L181" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="map_fine_to_coarse" class="level3">
<h3 class="anchored" data-anchor-id="map_fine_to_coarse">map_fine_to_coarse</h3>
<blockquote class="blockquote">
<pre><code> map_fine_to_coarse (sm, species, fine, coarse=None, plot=&lt;function umap&gt;,
                     include_coarse=False)</code></pre>
</blockquote>
<p>Extract the mapping of fine to coarse clusters from a SAMap object.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sm</td>
<td>sm.maps.SAMAP</td>
<td></td>
<td>SAMAP object to process.</td>
</tr>
<tr class="even">
<td>species</td>
<td>str</td>
<td></td>
<td>Species ID of the correct SAM object.</td>
</tr>
<tr class="odd">
<td>fine</td>
<td>str</td>
<td></td>
<td>Fine clustering slot name.</td>
</tr>
<tr class="even">
<td>coarse</td>
<td>NoneType</td>
<td>None</td>
<td>Coarse clustering slot name. If None, use the same as <code>fine</code>, mapping each cluster to<br>itself. (default: <code>None</code>).</td>
</tr>
<tr class="odd">
<td>plot</td>
<td>function</td>
<td>umap</td>
<td>Plotting function to use; this will correctly set the colors (default: <code>sc.pl.umap</code>).</td>
</tr>
<tr class="even">
<td>include_coarse</td>
<td>bool</td>
<td>False</td>
<td>If True, preface the fine cluster names with the coarse cluster names (default: <code>False</code>).</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>fine_to_coarse: pd.DataFrame</strong></td>
<td></td>
<td><strong>A dataframe with the mapping of fine to coarse clusters.</strong></td>
</tr>
</tbody>
</table>
<pre><code>/opt/hostedtoolcache/Python/3.9.19/x64/lib/python3.9/site-packages/fastcore/docscrape.py:225: UserWarning: potentially wrong underline length... 
Modifies 
------- in 
This function collapses unrelated clusters by identifying a major cluster category based on the
`coarse` column. It then assigns the major cluster category to all unrelated clusters in the...
  else: warn(msg)</code></pre>
<hr>
<p><a href="https://github.com/galicae/comandos/blob/main/comandos/util.py#L247" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="collapse_unrelated_clusters" class="level3">
<h3 class="anchored" data-anchor-id="collapse_unrelated_clusters">collapse_unrelated_clusters</h3>
<blockquote class="blockquote">
<pre><code> collapse_unrelated_clusters (adata:anndata._core.anndata.AnnData,
                              cluster:str, fine:str, coarse:str)</code></pre>
</blockquote>
<p>This function collapses unrelated clusters by identifying a major cluster category based on the <code>coarse</code> column. It then assigns the major cluster category to all unrelated clusters in the <code>fine</code> column. The resulting collapsed cluster information is stored in a new column named <code>fine + "_collapsed"</code>.</p>
<table class="table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>adata</td>
<td>AnnData</td>
<td>The annotation data containing the clusters to be collapsed.</td>
</tr>
<tr class="even">
<td>cluster</td>
<td>str</td>
<td>The cluster identifier within the <code>fine</code> column that needs to be collapsed.</td>
</tr>
<tr class="odd">
<td>fine</td>
<td>str</td>
<td>The column name representing the fine-grained clustering.</td>
</tr>
<tr class="even">
<td>coarse</td>
<td>str</td>
<td>The column name representing the coarse-grained clustering.</td>
</tr>
<tr class="odd">
<td><strong>Returns</strong></td>
<td><strong>None</strong></td>
<td></td>
</tr>
</tbody>
</table>
<div id="cell-34" class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="bu">file</span> <span class="op">=</span> <span class="bu">open</span>(os.environ[<span class="st">"EXAMPLE_DATA_PATH"</span>] <span class="op">+</span> <span class="st">"hypl.pkl"</span>, <span class="st">"rb"</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>sm <span class="op">=</span> pickle.load(<span class="bu">file</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>sm.sams[<span class="st">"hy"</span>].adata.obs[<span class="st">"coarse"</span>] <span class="op">=</span> (</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    sm.sams[<span class="st">"hy"</span>].adata.obs[<span class="st">"Cluster"</span>].<span class="bu">str</span>.split(<span class="st">"_"</span>).<span class="bu">str</span>[<span class="dv">0</span>]</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-35" class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>collapse_unrelated_clusters(sm.sams[<span class="st">"hy"</span>].adata, <span class="st">"ecEp_SC2"</span>, <span class="st">"Cluster"</span>, <span class="st">"coarse"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-36" class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>sm.sams[<span class="st">"hy"</span>].adata.obs[<span class="st">"Cluster"</span>].cat.categories</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>Index(['ecEp_SC2', 'ecEp_SC3', 'ecEp_bat1(mp)', 'ecEp_bat2(mp)', 'ecEp_bd',
       'ecEp_head', 'ecEp_nem1(pd)', 'ecEp_nem2(id)', 'enEp_SC1', 'enEp_SC2',
       'enEp_SC3', 'enEp_foot', 'enEp_head', 'enEp_nem1(pd)', 'enEp_nem2(pd)',
       'enEp_tent', 'enEp_tent(pd)', 'i_SC', 'i_fmgl1', 'i_fmgl2_nurse',
       'i_gmgc', 'i_mgl', 'i_nb1', 'i_nb2', 'i_nb3', 'i_nb4', 'i_nc1', 'i_nc2',
       'i_nc3', 'i_nc4', 'i_nc5', 'i_nc6', 'i_nc7', 'i_nc8', 'i_nc_gc_prog',
       'i_nc_prog', 'i_nem', 'i_smgc1', 'i_smgc2', 'i_zmg1', 'i_zmg2', 'nan'],
      dtype='object')</code></pre>
</div>
</div>
<div id="cell-37" class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>sm.sams[<span class="st">"hy"</span>].adata.obs[<span class="st">"Cluster_collapsed"</span>].cat.categories</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>Index(['ecEp_SC2', 'ecEp_SC3', 'ecEp_bat1(mp)', 'ecEp_bat2(mp)', 'ecEp_bd',
       'ecEp_head', 'ecEp_nem1(pd)', 'ecEp_nem2(id)', 'enEp', 'i', 'nan'],
      dtype='object')</code></pre>
</div>
</div>
<p>Notice that all subclusters in the <code>"ecEP"</code> group are still visible, but all other clusters are subsumed by their coarse cluster.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/galicae\.github\.io\/comandos");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/galicae/comandos/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>